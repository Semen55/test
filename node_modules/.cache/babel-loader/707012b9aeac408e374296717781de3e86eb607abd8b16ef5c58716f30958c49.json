{"ast":null,"code":"import _objectSpread from\"C:/Users/Samen/Documents/GitHub/test/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _taggedTemplateLiteral from\"C:/Users/Samen/Documents/GitHub/test/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\";var _templateObject,_templateObject2,_templateObject3,_templateObject4,_templateObject5,_templateObject6,_templateObject7,_templateObject8,_templateObject9,_templateObject0,_templateObject1,_templateObject10,_templateObject11;import*as React from'react';import styled from'styled-components';import GameControls from'./game-controls';import Map from'./map';import{shuffleArray}from'../logic/utils';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const GameContainer=styled.div(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n  display: flex;\\n  gap: 10px;\\n  padding: 10px;\\n  position: relative;\\n  height: calc(100% - 20px);\\n\"])));const MapWrapper=styled.div(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"\\n  position: relative;\\n  background: #a1cef6;\\n  border-radius: 10px;\\n  width: 80%;\\n  height: 100%;\\n\"])));const CaptureModalBackdrop=styled.div(_templateObject3||(_templateObject3=_taggedTemplateLiteral([\"\\n  position: absolute;\\n  inset: 0;\\n  background: transparent;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  z-index: 1000;\\n  pointer-events: none;\\n\"])));const CaptureModalCard=styled.div(_templateObject4||(_templateObject4=_taggedTemplateLiteral([\"\\n  background: #ffffff;\\n  border: 4px solid #000;\\n  border-radius: 0;\\n  padding: 0;\\n  width: 95%;\\n  max-width: 900px;\\n  height: auto;\\n  min-height: 400px;\\n  max-height: 90%;\\n  box-shadow: 0 24px 80px rgba(0, 0, 0, 0.5);\\n  display: flex;\\n  flex-direction: row;\\n  position: relative;\\n  overflow: visible;\\n  pointer-events: auto;\\n\"])));const CaptureModalContent=styled.div(_templateObject5||(_templateObject5=_taggedTemplateLiteral([\"\\n  flex: 1;\\n  padding: 32px;\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  text-align: center;\\n\"])));const CaptureModalImagePlaceholder=styled.div(_templateObject6||(_templateObject6=_taggedTemplateLiteral([\"\\n  width: 100%;\\n  max-width: 500px;\\n  height: auto;\\n  min-height: 50px;\\n  max-height: 400px;\\n  border: 2px solid #333;\\n  background: #f2f2f2;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  color: #777;\\n  font-size: 14px;\\n  margin-top: 15px;\\n  overflow: hidden;\\n\\n  img {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: contain;\\n    max-height: 400px;\\n  }\\n\"])));const CaptureModalTitle=styled.h2(_templateObject7||(_templateObject7=_taggedTemplateLiteral([\"\\n  margin: 0 0 12px;\\n  font-size: 24px;\\n  font-weight: normal;\\n  text-transform: uppercase;\\n\"])));const CaptureModalText=styled.p(_templateObject8||(_templateObject8=_taggedTemplateLiteral([\"\\n  margin: 0 0 15px;\\n  font-size: 16px;\\n  line-height: 1.4;\\n  color: #000;\\n  max-width: 700px;\\n\"])));const CaptureModalSideActions=styled.div(_templateObject9||(_templateObject9=_taggedTemplateLiteral([\"\\n  width: 100px;\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: \",\";\\n  align-items: center;\\n  gap: 15px;\\n  padding: 15px;\\n  \\n  &.left {\\n    border-right: none;\\n  }\\n  \\n  &.right {\\n    border-left: none;\\n  }\\n\"])),props=>props.isNeutral?'space-between':'flex-end');const CaptureButton=styled.button(_templateObject0||(_templateObject0=_taggedTemplateLiteral([\"\\n  position: relative;\\n  width: 70px;\\n  height: 70px;\\n  padding: 0;\\n  border-radius: 0;\\n  border: none;\\n  background: transparent;\\n  cursor: pointer;\\n  transition: transform 0.1s ease;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n\\n  &::after {\\n    content: attr(data-order);\\n    position: absolute;\\n    top: -5px;\\n    right: -5px;\\n    width: 24px;\\n    height: 24px;\\n    border-radius: 50%;\\n    background: #000;\\n    color: #fff;\\n    font-size: 14px;\\n    font-weight: bold;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n    opacity: \",\";\\n  }\\n\\n  &:active {\\n    transform: scale(0.95);\\n  }\\n\\n  &.active {\\n    filter: drop-shadow(0 0 8px rgba(0,0,0,0.5));\\n    transform: scale(1.1);\\n  }\\n\\n  img {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: contain;\\n  }\\n\"])),props=>props['data-order']?1:0);const ActionButton=styled.button(_templateObject1||(_templateObject1=_taggedTemplateLiteral([\"\\n  position: absolute;\\n  bottom: 20px;\\n  width: 60px;\\n  height: 60px;\\n  border-radius: 8px;\\n  border: none;\\n  cursor: \",\";\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  background: \",\";\\n  opacity: \",\";\\n  transition: all 0.2s ease;\\n  \\n  &:hover:not(:disabled) {\\n    transform: translateY(-2px);\\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\\n  }\\n  \\n  img {\\n    width: 70%;\\n    height: 70%;\\n    object-fit: contain;\\n  }\\n\"])),props=>props.disabled?'not-allowed':'pointer',props=>props.disabled?'#ccc':'#16a34a',props=>props.disabled?0.5:1);const UndoButton=styled(ActionButton)(_templateObject10||(_templateObject10=_taggedTemplateLiteral([\"\\n  left: 20px;\\n\"])));const RedoButton=styled(ActionButton)(_templateObject11||(_templateObject11=_taggedTemplateLiteral([\"\\n  right: 20px;\\n\"])));const shuffleTurnsOrder=arr=>arr.concat(arr.splice(0,1));const initialColors=shuffleArray(['#7975b9','#007F73','#FB9AD1','#FFC470','#C5FF95','#4793AF','#ff7171']);const Game=_ref=>{let{map}=_ref;const[teams,setTeams]=React.useState([]);const[gameState,setGameState]=React.useState('prepare');const[turnsOrder,setTurnsOrder]=React.useState([]);const[currentTurn,setCurrentTurn]=React.useState(null);const[roundNumber,setRoundNumber]=React.useState(0);const[activeTeam,setActiveTeam]=React.useState(null);const[pendingCaptureZone,setPendingCaptureZone]=React.useState(null);const[captureState,setCaptureState]=React.useState({attackerAnswered:false,defenderAnswered:false,attackerCorrect:null,defenderCorrect:null,firstResponder:null,isNeutral:false,attackerAnswer:null,defenderAnswer:null,responseOrder:[],isCapital:false,consecutiveWins:0,requiredWins:3,currentTask:null,capitalTasks:[]});const[availableTasks,setAvailableTasks]=React.useState([]);const[availableColors,setAvailableColors]=React.useState([...initialColors]);const[usedTaskIds,setUsedTaskIds]=React.useState(new Set());// Load available tasks on component mount\nReact.useEffect(()=>{const loadTasks=async()=>{try{const tasks=[];let taskNumber=1;// Loop to find all available tasks\nwhile(taskNumber<=100){try{// 1. Fetch the text file\nconst response=await fetch(\"/test/tasks/\".concat(taskNumber,\".txt\"));if(!response.ok)break;const text=await response.text();// CRITICAL FIX: Check if server returned HTML (index.html) instead of text\nif(text.trim().startsWith('<!DOCTYPE')||text.trim().startsWith('<html')){break;// Stop if we hit the fallback HTML\n}// 2. Check if image exists\nlet hasImage=false;try{const imgResponse=await fetch(\"/test/tasks/pics/\".concat(taskNumber,\".png\"),{method:'HEAD'});if(imgResponse.ok){const contentType=imgResponse.headers.get('content-type');// Only accept if it's actually an image or if we can't check content-type but response was OK\nif(!contentType||contentType.startsWith('image/')){hasImage=true;}}}catch(e){console.warn('Failed to check image',e);}tasks.push({id:taskNumber,text:text.trim(),imagePath:hasImage?\"/test/tasks/pics/\".concat(taskNumber,\".png\"):null});taskNumber++;}catch(error){break;}}setAvailableTasks(tasks);}catch(error){console.error('Error loading tasks:',error);}};loadTasks();},[]);// Helper function to select random tasks\nconst selectRandomTasks=React.useCallback(count=>{// Filter out used tasks\nconst unusedTasks=availableTasks.filter(task=>!usedTaskIds.has(task.id));if(unusedTasks.length===0)return[];const shuffled=[...unusedTasks].sort(()=>Math.random()-0.5);return shuffled.slice(0,Math.min(count,unusedTasks.length));},[availableTasks,usedTaskIds]);// History state\nconst[history,setHistory]=React.useState([]);const[future,setFuture]=React.useState([]);const recordAction=React.useCallback(()=>{const currentState={teams:JSON.parse(JSON.stringify(teams)),gameState,turnsOrder:[...turnsOrder],currentTurn,roundNumber,activeTeam,availableColors:[...availableColors],usedTaskIds:new Set(usedTaskIds),pendingCaptureZone,captureState:JSON.parse(JSON.stringify(captureState))};setHistory(prev=>[...prev,currentState]);setFuture([]);},[teams,gameState,turnsOrder,currentTurn,roundNumber,activeTeam,availableColors,usedTaskIds,pendingCaptureZone,captureState]);const restoreState=React.useCallback(state=>{setTeams(state.teams);setGameState(state.gameState);setTurnsOrder(state.turnsOrder);setCurrentTurn(state.currentTurn);setRoundNumber(state.roundNumber);setActiveTeam(state.activeTeam);setAvailableColors(state.availableColors);setUsedTaskIds(state.usedTaskIds||new Set());// Restore UI states\nsetPendingCaptureZone(state.pendingCaptureZone||null);// If we're restoring a capture state, reset the answered states\n// to prevent auto-resolution while keeping task information\nif(state.captureState){setCaptureState(_objectSpread(_objectSpread({},state.captureState),{},{attackerAnswered:false,defenderAnswered:false,attackerCorrect:null,defenderCorrect:null,attackerAnswer:null,defenderAnswer:null,responseOrder:[]}));}else{setCaptureState({attackerAnswered:false,defenderAnswered:false,attackerCorrect:null,defenderCorrect:null,firstResponder:null,isNeutral:false,attackerAnswer:null,defenderAnswer:null,responseOrder:[],isCapital:false,consecutiveWins:0,requiredWins:3,currentTask:null,capitalTasks:[]});}},[]);const undo=React.useCallback(()=>{// If capture window is open\nif(pendingCaptureZone!==null){// Special handling for capital attacks with multiple stages\nif(captureState.isCapital&&captureState.consecutiveWins>0){// Revert to previous stage instead of closing\nconst previousWins=captureState.consecutiveWins-1;const previousTask=captureState.capitalTasks[previousWins]||captureState.capitalTasks[0];setCaptureState(_objectSpread(_objectSpread({},captureState),{},{consecutiveWins:previousWins,currentTask:previousTask,attackerAnswered:false,defenderAnswered:false,attackerCorrect:null,defenderCorrect:null,attackerAnswer:null,defenderAnswer:null,responseOrder:[]}));return;}// For regular attacks or first stage of capital attack, close the window\n// Save the current state (with window open) to future before closing\nconst stateWithWindowOpen={teams:JSON.parse(JSON.stringify(teams)),gameState,turnsOrder:[...turnsOrder],currentTurn,roundNumber,activeTeam,availableColors:[...availableColors],usedTaskIds:new Set(usedTaskIds),pendingCaptureZone,captureState:JSON.parse(JSON.stringify(captureState))};setFuture(prev=>[stateWithWindowOpen,...prev]);setPendingCaptureZone(null);setCaptureState({attackerAnswered:false,defenderAnswered:false,attackerCorrect:null,defenderCorrect:null,firstResponder:null,isNeutral:false,attackerAnswer:null,defenderAnswer:null,responseOrder:[],isCapital:false,consecutiveWins:0,requiredWins:3,currentTask:null,capitalTasks:[]});// Also revert the used tasks that were marked when opening this window\n// by restoring from the last history state\nif(history.length>0){const lastState=history[history.length-1];if(lastState.usedTaskIds){setUsedTaskIds(lastState.usedTaskIds);}}return;}if(history.length===0)return;const previousState=history[history.length-1];const newHistory=history.slice(0,-1);const currentState={teams:JSON.parse(JSON.stringify(teams)),gameState,turnsOrder:[...turnsOrder],currentTurn,roundNumber,activeTeam,availableColors:[...availableColors],usedTaskIds:new Set(usedTaskIds),pendingCaptureZone,captureState:JSON.parse(JSON.stringify(captureState))};setFuture(prev=>[currentState,...prev]);setHistory(newHistory);restoreState(previousState);},[history,teams,gameState,turnsOrder,currentTurn,roundNumber,activeTeam,availableColors,usedTaskIds,pendingCaptureZone,captureState,restoreState]);const redo=React.useCallback(()=>{if(future.length===0)return;const nextState=future[0];const newFuture=future.slice(1);// Save current state to history before restoring\nconst currentState={teams:JSON.parse(JSON.stringify(teams)),gameState,turnsOrder:[...turnsOrder],currentTurn,roundNumber,activeTeam,availableColors:[...availableColors],usedTaskIds:new Set(usedTaskIds),pendingCaptureZone,captureState:JSON.parse(JSON.stringify(captureState))};setHistory(prev=>[...prev,currentState]);setFuture(newFuture);restoreState(nextState);},[future,teams,gameState,turnsOrder,currentTurn,roundNumber,activeTeam,availableColors,usedTaskIds,pendingCaptureZone,captureState,restoreState]);// Получаем basePositions из teams\nconst basePositions=React.useMemo(()=>{return teams.map(team=>team.base).filter(Boolean);},[teams]);const setBase=React.useCallback((zoneId,teamIndex)=>{const newTeams=[...teams];newTeams[teamIndex].base=zoneId;setTeams(newTeams);},[teams]);const toggleZoneToTeam=React.useCallback((zoneId,teamIndex)=>{const newTeams=[...teams];// Проверяем, есть ли уже эта территория у команды\nconst currentTeamHasZone=newTeams[teamIndex].zones.includes(zoneId);if(currentTeamHasZone){// Убираем территорию у команды\nnewTeams[teamIndex].zones=newTeams[teamIndex].zones.filter(z=>z!==zoneId);// Если это была столица, убираем и столицу\nif(newTeams[teamIndex].base===zoneId){newTeams[teamIndex].base=null;}}else{// Убираем территорию у предыдущего владельца\nfor(let i=0;i<newTeams.length;i++){if(newTeams[i].zones.includes(zoneId)){newTeams[i].zones=newTeams[i].zones.filter(z=>z!==zoneId);// Если у предыдущего владельца это была столица, убираем столицу\nif(newTeams[i].base===zoneId){newTeams[i].base=null;}break;}}// Добавляем территорию новой команде\nnewTeams[teamIndex].zones.push(zoneId);// Если это первая территория в режиме подготовки, устанавливаем столицу\nif(gameState==='prepare'&&!newTeams[teamIndex].base){newTeams[teamIndex].base=zoneId;}}setTeams(newTeams);},[teams,gameState]);const onTurnComplete=React.useCallback(()=>{const nextTeam=turnsOrder.slice(currentTurn+1).find(teamIndex=>teams[teamIndex].zones.length>0);if(typeof nextTeam!=='undefined'){setCurrentTurn(currentTurn+1);setActiveTeam(nextTeam);return;}setRoundNumber(roundNumber+1);setCurrentTurn(0);const newTurnsOrder=shuffleTurnsOrder([...turnsOrder].map(teamIndex=>teams[teamIndex].zones.length>0?teamIndex:undefined).filter(i=>typeof i!=='undefined'));setTurnsOrder(newTurnsOrder);setActiveTeam(newTurnsOrder[0]);},[currentTurn,roundNumber,teams,turnsOrder]);const onZoneClick=React.useCallback((zoneId,isRightClick)=>{if(gameState==='prepare'&&activeTeam!==null){recordAction();toggleZoneToTeam(zoneId,activeTeam);}if(gameState==='started'){// Ignore right-click\nif(isRightClick)return;const zoneOwner=teams.find(team=>team.zones.includes(zoneId));const zoneOwnerId=teams.findIndex(team=>team.zones.includes(zoneId));// neutral tile: ignore\nif(!zoneOwner){return;}// own tile: ignore\nif(zoneOwnerId===activeTeam){return;}// enemy tile: open confirmation window\nconst isCapital=zoneOwner.base===zoneId;// Select tasks for this attack\nlet selectedTasks=[];let currentTask=null;if(isCapital){// For capital, select 3 different tasks\nselectedTasks=selectRandomTasks(3);currentTask=selectedTasks[0]||null;}else{// For regular territory, select 1 task\nselectedTasks=selectRandomTasks(1);currentTask=selectedTasks[0]||null;}// Mark tasks as used\nif(selectedTasks.length>0){setUsedTaskIds(prev=>{const next=new Set(prev);selectedTasks.forEach(t=>next.add(t.id));return next;});}// Clear future/redo stack when starting a new attack\nsetFuture([]);setPendingCaptureZone(zoneId);setCaptureState({attackerAnswered:false,defenderAnswered:false,attackerCorrect:null,defenderCorrect:null,firstResponder:null,isNeutral:false,attackerAnswer:null,defenderAnswer:null,responseOrder:[],isCapital:isCapital,consecutiveWins:0,requiredWins:3,currentTask:currentTask,capitalTasks:selectedTasks});}},[activeTeam,gameState,onTurnComplete,teams,toggleZoneToTeam,recordAction,selectRandomTasks]);const cancelCapture=React.useCallback(()=>{setPendingCaptureZone(null);setCaptureState({attackerAnswered:false,defenderAnswered:false,attackerCorrect:null,defenderCorrect:null,firstResponder:null,isNeutral:false,attackerAnswer:null,defenderAnswer:null,responseOrder:[]});},[]);const maybeResolveCapture=React.useCallback((state,zoneId)=>{if(!state.attackerAnswered||!state.defenderAnswered)return;const zoneOwner=teams.find(team=>team.zones.includes(zoneId));const zoneOwnerId=teams.findIndex(team=>team.zones.includes(zoneId));if(!zoneOwner||zoneOwnerId===-1){return;}recordAction();let winner='defender';if(!state.attackerCorrect&&!state.defenderCorrect){winner='defender';}else if(state.attackerCorrect&&!state.defenderCorrect){winner='attacker';}else if(!state.attackerCorrect&&state.defenderCorrect){winner='defender';}else if(state.attackerCorrect&&state.defenderCorrect){winner=state.responseOrder[0]==='attacker'?'attacker':'defender';}const newTeams=[...teams];// Handle capital attack - need 3 consecutive wins\nif(state.isCapital&&winner==='attacker'){const newConsecutiveWins=state.consecutiveWins+1;if(newConsecutiveWins<state.requiredWins){// Not enough wins yet, reset the modal for next encounter\n// Use the next task for capital attacks\nconst nextTask=state.capitalTasks[newConsecutiveWins]||state.currentTask;setCaptureState({attackerAnswered:false,defenderAnswered:false,attackerCorrect:null,defenderCorrect:null,firstResponder:null,isNeutral:false,attackerAnswer:null,defenderAnswer:null,responseOrder:[],isCapital:true,consecutiveWins:newConsecutiveWins,requiredWins:state.requiredWins,currentTask:nextTask,capitalTasks:state.capitalTasks});return;// Keep modal open for next encounter\n}// If we reach here, attacker has won 3 times - continue to capture\n}else if(state.isCapital&&winner==='defender'){// Defender won, capital defense successful - close modal and end turn\n// Award 100 points to defender for successful defense\nnewTeams[zoneOwnerId].score+=100;setTeams(newTeams);setPendingCaptureZone(null);setCaptureState({attackerAnswered:false,defenderAnswered:false,attackerCorrect:null,defenderCorrect:null,firstResponder:null,isNeutral:false,attackerAnswer:null,defenderAnswer:null,responseOrder:[],isCapital:false,consecutiveWins:0,requiredWins:3,currentTask:null,capitalTasks:[]});onTurnComplete();return;}if(winner==='attacker'&&zoneOwnerId!==activeTeam){if(zoneOwner.base===zoneId){newTeams[activeTeam].score+=400;// Capture all zones of the defeated team\nconst zonesToCapture=[...newTeams[zoneOwnerId].zones];zonesToCapture.forEach(zone=>{if(zone!==zoneId){// Remove from defeated team\nnewTeams[zoneOwnerId].zones=newTeams[zoneOwnerId].zones.filter(z=>z!==zone);// Add to attacker team\nif(!newTeams[activeTeam].zones.includes(zone)){newTeams[activeTeam].zones.push(zone);}}});// Remove base from defeated team\nnewTeams[zoneOwnerId].base=null;// Capture the base zone\nnewTeams[zoneOwnerId].zones=newTeams[zoneOwnerId].zones.filter(z=>z!==zoneId);newTeams[activeTeam].zones.push(zoneId);newTeams[activeTeam].base=zoneId;}else{newTeams[activeTeam].score+=100;// Remove from defender and add to attacker\nnewTeams[zoneOwnerId].zones=newTeams[zoneOwnerId].zones.filter(z=>z!==zoneId);newTeams[activeTeam].zones.push(zoneId);}}else if(winner==='defender'){// Defender successfully defended - award 100 points\nnewTeams[zoneOwnerId].score+=100;}setTeams(newTeams);setPendingCaptureZone(null);setCaptureState({attackerAnswered:false,defenderAnswered:false,attackerCorrect:null,defenderCorrect:null,firstResponder:null,isNeutral:false,attackerAnswer:null,defenderAnswer:null,responseOrder:[],isCapital:false,consecutiveWins:0,requiredWins:3,currentTask:null,capitalTasks:[]});onTurnComplete();},[activeTeam,onTurnComplete,teams,recordAction]);React.useEffect(()=>{if(pendingCaptureZone&&!captureState.isNeutral&&captureState.attackerAnswered&&captureState.defenderAnswered){maybeResolveCapture(captureState,pendingCaptureZone);}},[captureState,pendingCaptureZone,maybeResolveCapture]);const handleAttackerAnswer=React.useCallback(isCorrect=>{if(!pendingCaptureZone)return;// Для вражеских территорий - переключаем выбор\nsetCaptureState(prev=>{// Если уже выбран этот вариант - отменяем выбор\nif(prev.attackerAnswer===isCorrect){return _objectSpread(_objectSpread({},prev),{},{attackerAnswer:null,attackerAnswered:false,responseOrder:prev.responseOrder.filter(item=>item!=='attacker')});}const newResponseOrder=[...prev.responseOrder];if(!newResponseOrder.includes('attacker')){newResponseOrder.push('attacker');}const next=_objectSpread(_objectSpread({},prev),{},{attackerAnswer:isCorrect,attackerAnswered:true,attackerCorrect:isCorrect,responseOrder:newResponseOrder});return next;});},[captureState.isNeutral,captureState.attackerAnswer,onTurnComplete,pendingCaptureZone,activeTeam,teams,recordAction]);const handleDefenderAnswer=React.useCallback(isCorrect=>{if(!pendingCaptureZone)return;setCaptureState(prev=>{// Если уже выбран этот вариант - отменяем выбор\nif(prev.defenderAnswer===isCorrect){return _objectSpread(_objectSpread({},prev),{},{defenderAnswer:null,defenderAnswered:false,responseOrder:prev.responseOrder.filter(item=>item!=='defender')});}const newResponseOrder=[...prev.responseOrder];if(!newResponseOrder.includes('defender')){newResponseOrder.push('defender');}const next=_objectSpread(_objectSpread({},prev),{},{defenderAnswer:isCorrect,defenderAnswered:true,defenderCorrect:isCorrect,responseOrder:newResponseOrder});return next;});},[pendingCaptureZone]);// Определяем порядок для отображения - теперь функция будет возвращать порядок только для активной кнопки\nconst getOrderForPlayer=(player,isActive)=>{if(!isActive)return'';const index=captureState.responseOrder.indexOf(player);return index!==-1?(index+1).toString():'';};return/*#__PURE__*/_jsxs(GameContainer,{children:[/*#__PURE__*/_jsxs(MapWrapper,{children:[/*#__PURE__*/_jsx(Map,{teams:teams,basePositions:basePositions,gameState:gameState,disabledZones:gameState==='prepare'&&activeTeam!==null?map.getAdjucentZones(teams.filter((_,index)=>index!==activeTeam).flatMap(team=>team.zones)):[],onZoneClick:onZoneClick}),/*#__PURE__*/_jsx(UndoButton,{disabled:history.length===0,onClick:undo,title:\"\\u041E\\u0442\\u043C\\u0435\\u043D\\u0438\\u0442\\u044C \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u0435\\u0435 \\u0434\\u0435\\u0439\\u0441\\u0442\\u0432\\u0438\\u0435\",children:/*#__PURE__*/_jsx(\"img\",{src:\"/test/images/undo-icon.png\",alt:\"\\u041E\\u0442\\u043C\\u0435\\u043D\\u0438\\u0442\\u044C\"})}),/*#__PURE__*/_jsx(RedoButton,{disabled:future.length===0,onClick:redo,title:\"\\u041F\\u043E\\u0432\\u0442\\u043E\\u0440\\u0438\\u0442\\u044C \\u043E\\u0442\\u043C\\u0435\\u043D\\u0435\\u043D\\u043D\\u043E\\u0435 \\u0434\\u0435\\u0439\\u0441\\u0442\\u0432\\u0438\\u0435\",children:/*#__PURE__*/_jsx(\"img\",{src:\"/test/images/redo-icon.png\",alt:\"\\u041F\\u043E\\u0432\\u0442\\u043E\\u0440\\u0438\\u0442\\u044C\"})}),pendingCaptureZone&&/*#__PURE__*/_jsx(CaptureModalBackdrop,{children:/*#__PURE__*/_jsxs(CaptureModalCard,{children:[/*#__PURE__*/_jsxs(CaptureModalSideActions,{className:\"left\",isNeutral:false,children:[/*#__PURE__*/_jsx(CaptureButton,{className:captureState.defenderAnswer===false?'active':'',onClick:()=>handleDefenderAnswer(false),\"data-order\":getOrderForPlayer('defender',captureState.defenderAnswer===false),children:/*#__PURE__*/_jsx(\"img\",{src:\"/test/images/defend-wrong-icon.png\",alt:\"\\u0417\\u0430\\u0449\\u0438\\u0442\\u0430 \\u043D\\u0435\\u0432\\u0435\\u0440\\u043D\\u043E\"})}),/*#__PURE__*/_jsx(CaptureButton,{className:captureState.defenderAnswer===true?'active':'',onClick:()=>handleDefenderAnswer(true),\"data-order\":getOrderForPlayer('defender',captureState.defenderAnswer===true),children:/*#__PURE__*/_jsx(\"img\",{src:\"/test/images/defend-correct-icon.png\",alt:\"\\u0417\\u0430\\u0449\\u0438\\u0442\\u0430 \\u0432\\u0435\\u0440\\u043D\\u043E\"})})]}),/*#__PURE__*/_jsxs(CaptureModalContent,{children:[/*#__PURE__*/_jsxs(CaptureModalTitle,{children:[\"\\u0420\\u0415\\u0413\\u0418\\u041E\\u041D \",pendingCaptureZone,\" \",captureState.isCapital&&\"(\\u0421\\u0422\\u041E\\u041B\\u0418\\u0426\\u0410 \".concat(captureState.consecutiveWins,\"/\").concat(captureState.requiredWins,\")\")]}),/*#__PURE__*/_jsx(CaptureModalText,{children:captureState.currentTask?captureState.currentTask.text:availableTasks.length>0&&usedTaskIds.size>=availableTasks.length?'Задач нет':captureState.isCapital?\"\\u0410\\u0442\\u0430\\u043A\\u0430 \\u043D\\u0430 \\u0441\\u0442\\u043E\\u043B\\u0438\\u0446\\u0443! \\u0414\\u043B\\u044F \\u0437\\u0430\\u0445\\u0432\\u0430\\u0442\\u0430 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E \\u043F\\u043E\\u0431\\u0435\\u0434\\u0438\\u0442\\u044C \\u0432 \".concat(captureState.requiredWins,\" \\u0441\\u0445\\u0432\\u0430\\u0442\\u043A\\u0430\\u0445 \\u043F\\u043E\\u0434\\u0440\\u044F\\u0434.\"):'Захват вражеской территории. Здесь будет описание задания или подсказка для игрока. После выполнения задания выберите результат атаки для атакующих и защищающихся.'}),captureState.currentTask&&captureState.currentTask.imagePath&&/*#__PURE__*/_jsx(CaptureModalImagePlaceholder,{children:/*#__PURE__*/_jsx(\"img\",{src:captureState.currentTask.imagePath,alt:\"Task illustration\"})})]}),/*#__PURE__*/_jsxs(CaptureModalSideActions,{className:\"right\",isNeutral:false,children:[/*#__PURE__*/_jsx(CaptureButton,{className:captureState.attackerAnswer===false?'active':'',onClick:()=>handleAttackerAnswer(false),\"data-order\":getOrderForPlayer('attacker',captureState.attackerAnswer===false),children:/*#__PURE__*/_jsx(\"img\",{src:\"/test/images/attack-wrong-icon.png\",alt:\"\\u0410\\u0442\\u0430\\u043A\\u0430 \\u043D\\u0435\\u0432\\u0435\\u0440\\u043D\\u043E\"})}),/*#__PURE__*/_jsx(CaptureButton,{className:captureState.attackerAnswer===true?'active':'',onClick:()=>handleAttackerAnswer(true),\"data-order\":getOrderForPlayer('attacker',captureState.attackerAnswer===true),children:/*#__PURE__*/_jsx(\"img\",{src:\"/test/images/attack-correct-icon.png\",alt:\"\\u0410\\u0442\\u0430\\u043A\\u0430 \\u0432\\u0435\\u0440\\u043D\\u043E\"})})]})]})})]}),/*#__PURE__*/_jsx(GameControls,{teams:teams,activeTeam:activeTeam,pendingCaptureZone:pendingCaptureZone,captureState:captureState,onTeamAdded:teamName=>{const color=availableColors[availableColors.length-1];const newAvailableColors=availableColors.slice(0,-1);recordAction();const newTeams=[...teams,{name:teamName,score:1000,zones:[],color:color,base:null}];setTeams(newTeams);setAvailableColors(newAvailableColors);},onTeamClick:teamIndex=>{if(gameState==='prepare'){recordAction();setActiveTeam(teamIndex===activeTeam?null:teamIndex);}},onGameStart:()=>{recordAction();setGameState('started');setCurrentTurn(0);setRoundNumber(1);setTurnsOrder(teams.map((tmp,index)=>index));setActiveTeam(0);},onTurnComplete:()=>{recordAction();onTurnComplete();},gameState:gameState,currentTurn:turnsOrder[currentTurn],roundNumber:roundNumber})]});};export default Game;","map":{"version":3,"names":["React","styled","GameControls","Map","shuffleArray","jsx","_jsx","jsxs","_jsxs","GameContainer","div","_templateObject","_taggedTemplateLiteral","MapWrapper","_templateObject2","CaptureModalBackdrop","_templateObject3","CaptureModalCard","_templateObject4","CaptureModalContent","_templateObject5","CaptureModalImagePlaceholder","_templateObject6","CaptureModalTitle","h2","_templateObject7","CaptureModalText","p","_templateObject8","CaptureModalSideActions","_templateObject9","props","isNeutral","CaptureButton","button","_templateObject0","ActionButton","_templateObject1","disabled","UndoButton","_templateObject10","RedoButton","_templateObject11","shuffleTurnsOrder","arr","concat","splice","initialColors","Game","_ref","map","teams","setTeams","useState","gameState","setGameState","turnsOrder","setTurnsOrder","currentTurn","setCurrentTurn","roundNumber","setRoundNumber","activeTeam","setActiveTeam","pendingCaptureZone","setPendingCaptureZone","captureState","setCaptureState","attackerAnswered","defenderAnswered","attackerCorrect","defenderCorrect","firstResponder","attackerAnswer","defenderAnswer","responseOrder","isCapital","consecutiveWins","requiredWins","currentTask","capitalTasks","availableTasks","setAvailableTasks","availableColors","setAvailableColors","usedTaskIds","setUsedTaskIds","Set","useEffect","loadTasks","tasks","taskNumber","response","fetch","ok","text","trim","startsWith","hasImage","imgResponse","method","contentType","headers","get","e","console","warn","push","id","imagePath","error","selectRandomTasks","useCallback","count","unusedTasks","filter","task","has","length","shuffled","sort","Math","random","slice","min","history","setHistory","future","setFuture","recordAction","currentState","JSON","parse","stringify","prev","restoreState","state","_objectSpread","undo","previousWins","previousTask","stateWithWindowOpen","lastState","previousState","newHistory","redo","nextState","newFuture","basePositions","useMemo","team","base","Boolean","setBase","zoneId","teamIndex","newTeams","toggleZoneToTeam","currentTeamHasZone","zones","includes","z","i","onTurnComplete","nextTeam","find","newTurnsOrder","undefined","onZoneClick","isRightClick","zoneOwner","zoneOwnerId","findIndex","selectedTasks","next","forEach","t","add","cancelCapture","maybeResolveCapture","winner","newConsecutiveWins","nextTask","score","zonesToCapture","zone","handleAttackerAnswer","isCorrect","item","newResponseOrder","handleDefenderAnswer","getOrderForPlayer","player","isActive","index","indexOf","toString","children","disabledZones","getAdjucentZones","_","flatMap","onClick","title","src","alt","className","size","onTeamAdded","teamName","color","newAvailableColors","name","onTeamClick","onGameStart","tmp"],"sources":["C:/Users/Samen/Documents/GitHub/test/src/components/game.js"],"sourcesContent":["import * as React from 'react';\r\nimport styled from 'styled-components';\r\nimport GameControls from './game-controls';\r\nimport Map from './map';\r\nimport { shuffleArray } from '../logic/utils';\r\n\r\nconst GameContainer = styled.div`\r\n  display: flex;\r\n  gap: 10px;\r\n  padding: 10px;\r\n  position: relative;\r\n  height: calc(100% - 20px);\r\n`;\r\n\r\nconst MapWrapper = styled.div`\r\n  position: relative;\r\n  background: #a1cef6;\r\n  border-radius: 10px;\r\n  width: 80%;\r\n  height: 100%;\r\n`;\r\n\r\nconst CaptureModalBackdrop = styled.div`\r\n  position: absolute;\r\n  inset: 0;\r\n  background: transparent;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 1000;\r\n  pointer-events: none;\r\n`;\r\n\r\nconst CaptureModalCard = styled.div`\r\n  background: #ffffff;\r\n  border: 4px solid #000;\r\n  border-radius: 0;\r\n  padding: 0;\r\n  width: 95%;\r\n  max-width: 900px;\r\n  height: auto;\r\n  min-height: 400px;\r\n  max-height: 90%;\r\n  box-shadow: 0 24px 80px rgba(0, 0, 0, 0.5);\r\n  display: flex;\r\n  flex-direction: row;\r\n  position: relative;\r\n  overflow: visible;\r\n  pointer-events: auto;\r\n`;\r\n\r\nconst CaptureModalContent = styled.div`\r\n  flex: 1;\r\n  padding: 32px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  text-align: center;\r\n`;\r\n\r\nconst CaptureModalImagePlaceholder = styled.div`\r\n  width: 100%;\r\n  max-width: 500px;\r\n  height: auto;\r\n  min-height: 50px;\r\n  max-height: 400px;\r\n  border: 2px solid #333;\r\n  background: #f2f2f2;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  color: #777;\r\n  font-size: 14px;\r\n  margin-top: 15px;\r\n  overflow: hidden;\r\n\r\n  img {\r\n    width: 100%;\r\n    height: 100%;\r\n    object-fit: contain;\r\n    max-height: 400px;\r\n  }\r\n`;\r\n\r\nconst CaptureModalTitle = styled.h2`\r\n  margin: 0 0 12px;\r\n  font-size: 24px;\r\n  font-weight: normal;\r\n  text-transform: uppercase;\r\n`;\r\n\r\nconst CaptureModalText = styled.p`\r\n  margin: 0 0 15px;\r\n  font-size: 16px;\r\n  line-height: 1.4;\r\n  color: #000;\r\n  max-width: 700px;\r\n`;\r\n\r\nconst CaptureModalSideActions = styled.div`\r\n  width: 100px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: ${props => props.isNeutral ? 'space-between' : 'flex-end'};\r\n  align-items: center;\r\n  gap: 15px;\r\n  padding: 15px;\r\n  \r\n  &.left {\r\n    border-right: none;\r\n  }\r\n  \r\n  &.right {\r\n    border-left: none;\r\n  }\r\n`;\r\n\r\nconst CaptureButton = styled.button`\r\n  position: relative;\r\n  width: 70px;\r\n  height: 70px;\r\n  padding: 0;\r\n  border-radius: 0;\r\n  border: none;\r\n  background: transparent;\r\n  cursor: pointer;\r\n  transition: transform 0.1s ease;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n\r\n  &::after {\r\n    content: attr(data-order);\r\n    position: absolute;\r\n    top: -5px;\r\n    right: -5px;\r\n    width: 24px;\r\n    height: 24px;\r\n    border-radius: 50%;\r\n    background: #000;\r\n    color: #fff;\r\n    font-size: 14px;\r\n    font-weight: bold;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    opacity: ${props => props['data-order'] ? 1 : 0};\r\n  }\r\n\r\n  &:active {\r\n    transform: scale(0.95);\r\n  }\r\n\r\n  &.active {\r\n    filter: drop-shadow(0 0 8px rgba(0,0,0,0.5));\r\n    transform: scale(1.1);\r\n  }\r\n\r\n  img {\r\n    width: 100%;\r\n    height: 100%;\r\n    object-fit: contain;\r\n  }\r\n`;\r\n\r\nconst ActionButton = styled.button`\r\n  position: absolute;\r\n  bottom: 20px;\r\n  width: 60px;\r\n  height: 60px;\r\n  border-radius: 8px;\r\n  border: none;\r\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background: ${props => props.disabled ? '#ccc' : '#16a34a'};\r\n  opacity: ${props => props.disabled ? 0.5 : 1};\r\n  transition: all 0.2s ease;\r\n  \r\n  &:hover:not(:disabled) {\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\r\n  }\r\n  \r\n  img {\r\n    width: 70%;\r\n    height: 70%;\r\n    object-fit: contain;\r\n  }\r\n`;\r\n\r\nconst UndoButton = styled(ActionButton)`\r\n  left: 20px;\r\n`;\r\n\r\nconst RedoButton = styled(ActionButton)`\r\n  right: 20px;\r\n`;\r\n\r\nconst shuffleTurnsOrder = (arr) => arr.concat(arr.splice(0, 1));\r\n\r\nconst initialColors = shuffleArray([\r\n  '#7975b9',\r\n  '#007F73',\r\n  '#FB9AD1',\r\n  '#FFC470',\r\n  '#C5FF95',\r\n  '#4793AF',\r\n  '#ff7171',\r\n]);\r\n\r\nconst Game = ({ map }) => {\r\n  const [teams, setTeams] = React.useState([]);\r\n  const [gameState, setGameState] = React.useState('prepare');\r\n  const [turnsOrder, setTurnsOrder] = React.useState([]);\r\n  const [currentTurn, setCurrentTurn] = React.useState(null);\r\n  const [roundNumber, setRoundNumber] = React.useState(0);\r\n  const [activeTeam, setActiveTeam] = React.useState(null);\r\n  const [pendingCaptureZone, setPendingCaptureZone] = React.useState(null);\r\n  const [captureState, setCaptureState] = React.useState({\r\n    attackerAnswered: false,\r\n    defenderAnswered: false,\r\n    attackerCorrect: null,\r\n    defenderCorrect: null,\r\n    firstResponder: null,\r\n    isNeutral: false,\r\n    attackerAnswer: null,\r\n    defenderAnswer: null,\r\n    responseOrder: [],\r\n    isCapital: false,\r\n    consecutiveWins: 0,\r\n    requiredWins: 3,\r\n    currentTask: null,\r\n    capitalTasks: [],\r\n  });\r\n\r\n  const [availableTasks, setAvailableTasks] = React.useState([]);\r\n\r\n  const [availableColors, setAvailableColors] = React.useState([...initialColors]);\r\n  const [usedTaskIds, setUsedTaskIds] = React.useState(new Set());\r\n\r\n  // Load available tasks on component mount\r\n  React.useEffect(() => {\r\n    const loadTasks = async () => {\r\n      try {\r\n        const tasks = [];\r\n        let taskNumber = 1;\r\n\r\n        // Loop to find all available tasks\r\n        while (taskNumber <= 100) {\r\n          try {\r\n            // 1. Fetch the text file\r\n            const response = await fetch(`/test/tasks/${taskNumber}.txt`);\r\n            if (!response.ok) break;\r\n\r\n            const text = await response.text();\r\n\r\n            // CRITICAL FIX: Check if server returned HTML (index.html) instead of text\r\n            if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {\r\n              break; // Stop if we hit the fallback HTML\r\n            }\r\n\r\n            // 2. Check if image exists\r\n            let hasImage = false;\r\n            try {\r\n              const imgResponse = await fetch(`/test/tasks/pics/${taskNumber}.png`, { method: 'HEAD' });\r\n              if (imgResponse.ok) {\r\n                const contentType = imgResponse.headers.get('content-type');\r\n                // Only accept if it's actually an image or if we can't check content-type but response was OK\r\n                if (!contentType || contentType.startsWith('image/')) {\r\n                  hasImage = true;\r\n                }\r\n              }\r\n            } catch (e) {\r\n              console.warn('Failed to check image', e);\r\n            }\r\n\r\n            tasks.push({\r\n              id: taskNumber,\r\n              text: text.trim(),\r\n              imagePath: hasImage ? `/test/tasks/pics/${taskNumber}.png` : null,\r\n            });\r\n\r\n            taskNumber++;\r\n          } catch (error) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        setAvailableTasks(tasks);\r\n      } catch (error) {\r\n        console.error('Error loading tasks:', error);\r\n      }\r\n    };\r\n\r\n    loadTasks();\r\n  }, []);\r\n\r\n  // Helper function to select random tasks\r\n  const selectRandomTasks = React.useCallback((count) => {\r\n    // Filter out used tasks\r\n    const unusedTasks = availableTasks.filter(task => !usedTaskIds.has(task.id));\r\n\r\n    if (unusedTasks.length === 0) return [];\r\n\r\n    const shuffled = [...unusedTasks].sort(() => Math.random() - 0.5);\r\n    return shuffled.slice(0, Math.min(count, unusedTasks.length));\r\n  }, [availableTasks, usedTaskIds]);\r\n\r\n  // History state\r\n  const [history, setHistory] = React.useState([]);\r\n  const [future, setFuture] = React.useState([]);\r\n\r\n  const recordAction = React.useCallback(() => {\r\n    const currentState = {\r\n      teams: JSON.parse(JSON.stringify(teams)),\r\n      gameState,\r\n      turnsOrder: [...turnsOrder],\r\n      currentTurn,\r\n      roundNumber,\r\n      activeTeam,\r\n      availableColors: [...availableColors],\r\n      usedTaskIds: new Set(usedTaskIds),\r\n      pendingCaptureZone,\r\n      captureState: JSON.parse(JSON.stringify(captureState)),\r\n    };\r\n    setHistory((prev) => [...prev, currentState]);\r\n    setFuture([]);\r\n  }, [teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors, usedTaskIds, pendingCaptureZone, captureState]);\r\n\r\n  const restoreState = React.useCallback((state) => {\r\n    setTeams(state.teams);\r\n    setGameState(state.gameState);\r\n    setTurnsOrder(state.turnsOrder);\r\n    setCurrentTurn(state.currentTurn);\r\n    setRoundNumber(state.roundNumber);\r\n    setActiveTeam(state.activeTeam);\r\n    setAvailableColors(state.availableColors);\r\n    setUsedTaskIds(state.usedTaskIds || new Set());\r\n\r\n    // Restore UI states\r\n    setPendingCaptureZone(state.pendingCaptureZone || null);\r\n\r\n    // If we're restoring a capture state, reset the answered states\r\n    // to prevent auto-resolution while keeping task information\r\n    if (state.captureState) {\r\n      setCaptureState({\r\n        ...state.captureState,\r\n        attackerAnswered: false,\r\n        defenderAnswered: false,\r\n        attackerCorrect: null,\r\n        defenderCorrect: null,\r\n        attackerAnswer: null,\r\n        defenderAnswer: null,\r\n        responseOrder: [],\r\n      });\r\n    } else {\r\n      setCaptureState({\r\n        attackerAnswered: false,\r\n        defenderAnswered: false,\r\n        attackerCorrect: null,\r\n        defenderCorrect: null,\r\n        firstResponder: null,\r\n        isNeutral: false,\r\n        attackerAnswer: null,\r\n        defenderAnswer: null,\r\n        responseOrder: [],\r\n        isCapital: false,\r\n        consecutiveWins: 0,\r\n        requiredWins: 3,\r\n        currentTask: null,\r\n        capitalTasks: [],\r\n      });\r\n    }\r\n  }, []);\r\n\r\n  const undo = React.useCallback(() => {\r\n    // If capture window is open\r\n    if (pendingCaptureZone !== null) {\r\n      // Special handling for capital attacks with multiple stages\r\n      if (captureState.isCapital && captureState.consecutiveWins > 0) {\r\n        // Revert to previous stage instead of closing\r\n        const previousWins = captureState.consecutiveWins - 1;\r\n        const previousTask = captureState.capitalTasks[previousWins] || captureState.capitalTasks[0];\r\n\r\n        setCaptureState({\r\n          ...captureState,\r\n          consecutiveWins: previousWins,\r\n          currentTask: previousTask,\r\n          attackerAnswered: false,\r\n          defenderAnswered: false,\r\n          attackerCorrect: null,\r\n          defenderCorrect: null,\r\n          attackerAnswer: null,\r\n          defenderAnswer: null,\r\n          responseOrder: [],\r\n        });\r\n        return;\r\n      }\r\n\r\n      // For regular attacks or first stage of capital attack, close the window\r\n      // Save the current state (with window open) to future before closing\r\n      const stateWithWindowOpen = {\r\n        teams: JSON.parse(JSON.stringify(teams)),\r\n        gameState,\r\n        turnsOrder: [...turnsOrder],\r\n        currentTurn,\r\n        roundNumber,\r\n        activeTeam,\r\n        availableColors: [...availableColors],\r\n        usedTaskIds: new Set(usedTaskIds),\r\n        pendingCaptureZone,\r\n        captureState: JSON.parse(JSON.stringify(captureState)),\r\n      };\r\n\r\n      setFuture((prev) => [stateWithWindowOpen, ...prev]);\r\n\r\n      setPendingCaptureZone(null);\r\n      setCaptureState({\r\n        attackerAnswered: false,\r\n        defenderAnswered: false,\r\n        attackerCorrect: null,\r\n        defenderCorrect: null,\r\n        firstResponder: null,\r\n        isNeutral: false,\r\n        attackerAnswer: null,\r\n        defenderAnswer: null,\r\n        responseOrder: [],\r\n        isCapital: false,\r\n        consecutiveWins: 0,\r\n        requiredWins: 3,\r\n        currentTask: null,\r\n        capitalTasks: [],\r\n      });\r\n\r\n      // Also revert the used tasks that were marked when opening this window\r\n      // by restoring from the last history state\r\n      if (history.length > 0) {\r\n        const lastState = history[history.length - 1];\r\n        if (lastState.usedTaskIds) {\r\n          setUsedTaskIds(lastState.usedTaskIds);\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (history.length === 0) return;\r\n\r\n    const previousState = history[history.length - 1];\r\n    const newHistory = history.slice(0, -1);\r\n\r\n    const currentState = {\r\n      teams: JSON.parse(JSON.stringify(teams)),\r\n      gameState,\r\n      turnsOrder: [...turnsOrder],\r\n      currentTurn,\r\n      roundNumber,\r\n      activeTeam,\r\n      availableColors: [...availableColors],\r\n      usedTaskIds: new Set(usedTaskIds),\r\n      pendingCaptureZone,\r\n      captureState: JSON.parse(JSON.stringify(captureState)),\r\n    };\r\n\r\n    setFuture((prev) => [currentState, ...prev]);\r\n    setHistory(newHistory);\r\n    restoreState(previousState);\r\n  }, [history, teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors, usedTaskIds, pendingCaptureZone, captureState, restoreState]);\r\n\r\n  const redo = React.useCallback(() => {\r\n    if (future.length === 0) return;\r\n\r\n    const nextState = future[0];\r\n    const newFuture = future.slice(1);\r\n\r\n    // Save current state to history before restoring\r\n    const currentState = {\r\n      teams: JSON.parse(JSON.stringify(teams)),\r\n      gameState,\r\n      turnsOrder: [...turnsOrder],\r\n      currentTurn,\r\n      roundNumber,\r\n      activeTeam,\r\n      availableColors: [...availableColors],\r\n      usedTaskIds: new Set(usedTaskIds),\r\n      pendingCaptureZone,\r\n      captureState: JSON.parse(JSON.stringify(captureState)),\r\n    };\r\n\r\n    setHistory((prev) => [...prev, currentState]);\r\n    setFuture(newFuture);\r\n    restoreState(nextState);\r\n  }, [future, teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors, usedTaskIds, pendingCaptureZone, captureState, restoreState]);\r\n\r\n  // Получаем basePositions из teams\r\n  const basePositions = React.useMemo(() => {\r\n    return teams.map(team => team.base).filter(Boolean);\r\n  }, [teams]);\r\n\r\n  const setBase = React.useCallback(\r\n    (zoneId, teamIndex) => {\r\n      const newTeams = [...teams];\r\n      newTeams[teamIndex].base = zoneId;\r\n      setTeams(newTeams);\r\n    },\r\n    [teams]\r\n  );\r\n\r\n  const toggleZoneToTeam = React.useCallback(\r\n    (zoneId, teamIndex) => {\r\n      const newTeams = [...teams];\r\n\r\n      // Проверяем, есть ли уже эта территория у команды\r\n      const currentTeamHasZone = newTeams[teamIndex].zones.includes(zoneId);\r\n\r\n      if (currentTeamHasZone) {\r\n        // Убираем территорию у команды\r\n        newTeams[teamIndex].zones = newTeams[teamIndex].zones.filter((z) => z !== zoneId);\r\n\r\n        // Если это была столица, убираем и столицу\r\n        if (newTeams[teamIndex].base === zoneId) {\r\n          newTeams[teamIndex].base = null;\r\n        }\r\n      } else {\r\n        // Убираем территорию у предыдущего владельца\r\n        for (let i = 0; i < newTeams.length; i++) {\r\n          if (newTeams[i].zones.includes(zoneId)) {\r\n            newTeams[i].zones = newTeams[i].zones.filter((z) => z !== zoneId);\r\n\r\n            // Если у предыдущего владельца это была столица, убираем столицу\r\n            if (newTeams[i].base === zoneId) {\r\n              newTeams[i].base = null;\r\n            }\r\n            break;\r\n          }\r\n        }\r\n\r\n        // Добавляем территорию новой команде\r\n        newTeams[teamIndex].zones.push(zoneId);\r\n\r\n        // Если это первая территория в режиме подготовки, устанавливаем столицу\r\n        if (gameState === 'prepare' && !newTeams[teamIndex].base) {\r\n          newTeams[teamIndex].base = zoneId;\r\n        }\r\n      }\r\n\r\n      setTeams(newTeams);\r\n    },\r\n    [teams, gameState]\r\n  );\r\n\r\n  const onTurnComplete = React.useCallback(() => {\r\n    const nextTeam = turnsOrder\r\n      .slice(currentTurn + 1)\r\n      .find((teamIndex) => teams[teamIndex].zones.length > 0);\r\n\r\n    if (typeof nextTeam !== 'undefined') {\r\n      setCurrentTurn(currentTurn + 1);\r\n      setActiveTeam(nextTeam);\r\n      return;\r\n    }\r\n\r\n    setRoundNumber(roundNumber + 1);\r\n    setCurrentTurn(0);\r\n\r\n    const newTurnsOrder = shuffleTurnsOrder(\r\n      [...turnsOrder]\r\n        .map((teamIndex) => (teams[teamIndex].zones.length > 0 ? teamIndex : undefined))\r\n        .filter((i) => typeof i !== 'undefined')\r\n    );\r\n\r\n    setTurnsOrder(newTurnsOrder);\r\n    setActiveTeam(newTurnsOrder[0]);\r\n  }, [currentTurn, roundNumber, teams, turnsOrder]);\r\n\r\n  const onZoneClick = React.useCallback(\r\n    (zoneId, isRightClick) => {\r\n      if (gameState === 'prepare' && activeTeam !== null) {\r\n        recordAction();\r\n        toggleZoneToTeam(zoneId, activeTeam);\r\n      }\r\n      if (gameState === 'started') {\r\n        // Ignore right-click\r\n        if (isRightClick) return;\r\n\r\n        const zoneOwner = teams.find((team) => team.zones.includes(zoneId));\r\n        const zoneOwnerId = teams.findIndex((team) => team.zones.includes(zoneId));\r\n\r\n        // neutral tile: ignore\r\n        if (!zoneOwner) {\r\n          return;\r\n        }\r\n\r\n        // own tile: ignore\r\n        if (zoneOwnerId === activeTeam) {\r\n          return;\r\n        }\r\n\r\n        // enemy tile: open confirmation window\r\n        const isCapital = zoneOwner.base === zoneId;\r\n\r\n        // Select tasks for this attack\r\n        let selectedTasks = [];\r\n        let currentTask = null;\r\n\r\n        if (isCapital) {\r\n          // For capital, select 3 different tasks\r\n          selectedTasks = selectRandomTasks(3);\r\n          currentTask = selectedTasks[0] || null;\r\n        } else {\r\n          // For regular territory, select 1 task\r\n          selectedTasks = selectRandomTasks(1);\r\n          currentTask = selectedTasks[0] || null;\r\n        }\r\n\r\n        // Mark tasks as used\r\n        if (selectedTasks.length > 0) {\r\n          setUsedTaskIds(prev => {\r\n            const next = new Set(prev);\r\n            selectedTasks.forEach(t => next.add(t.id));\r\n            return next;\r\n          });\r\n        }\r\n\r\n        // Clear future/redo stack when starting a new attack\r\n        setFuture([]);\r\n\r\n        setPendingCaptureZone(zoneId);\r\n        setCaptureState({\r\n          attackerAnswered: false,\r\n          defenderAnswered: false,\r\n          attackerCorrect: null,\r\n          defenderCorrect: null,\r\n          firstResponder: null,\r\n          isNeutral: false,\r\n          attackerAnswer: null,\r\n          defenderAnswer: null,\r\n          responseOrder: [],\r\n          isCapital: isCapital,\r\n          consecutiveWins: 0,\r\n          requiredWins: 3,\r\n          currentTask: currentTask,\r\n          capitalTasks: selectedTasks,\r\n        });\r\n      }\r\n    },\r\n    [activeTeam, gameState, onTurnComplete, teams, toggleZoneToTeam, recordAction, selectRandomTasks]\r\n  );\r\n\r\n  const cancelCapture = React.useCallback(() => {\r\n    setPendingCaptureZone(null);\r\n    setCaptureState({\r\n      attackerAnswered: false,\r\n      defenderAnswered: false,\r\n      attackerCorrect: null,\r\n      defenderCorrect: null,\r\n      firstResponder: null,\r\n      isNeutral: false,\r\n      attackerAnswer: null,\r\n      defenderAnswer: null,\r\n      responseOrder: [],\r\n    });\r\n  }, []);\r\n\r\n  const maybeResolveCapture = React.useCallback(\r\n    (state, zoneId) => {\r\n      if (!state.attackerAnswered || !state.defenderAnswered) return;\r\n\r\n      const zoneOwner = teams.find((team) => team.zones.includes(zoneId));\r\n      const zoneOwnerId = teams.findIndex((team) => team.zones.includes(zoneId));\r\n      if (!zoneOwner || zoneOwnerId === -1) {\r\n        return;\r\n      }\r\n\r\n      recordAction();\r\n\r\n      let winner = 'defender';\r\n\r\n      if (!state.attackerCorrect && !state.defenderCorrect) {\r\n        winner = 'defender';\r\n      } else if (state.attackerCorrect && !state.defenderCorrect) {\r\n        winner = 'attacker';\r\n      } else if (!state.attackerCorrect && state.defenderCorrect) {\r\n        winner = 'defender';\r\n      } else if (state.attackerCorrect && state.defenderCorrect) {\r\n        winner = state.responseOrder[0] === 'attacker' ? 'attacker' : 'defender';\r\n      }\r\n\r\n      const newTeams = [...teams];\r\n\r\n      // Handle capital attack - need 3 consecutive wins\r\n      if (state.isCapital && winner === 'attacker') {\r\n        const newConsecutiveWins = state.consecutiveWins + 1;\r\n\r\n        if (newConsecutiveWins < state.requiredWins) {\r\n          // Not enough wins yet, reset the modal for next encounter\r\n          // Use the next task for capital attacks\r\n          const nextTask = state.capitalTasks[newConsecutiveWins] || state.currentTask;\r\n\r\n          setCaptureState({\r\n            attackerAnswered: false,\r\n            defenderAnswered: false,\r\n            attackerCorrect: null,\r\n            defenderCorrect: null,\r\n            firstResponder: null,\r\n            isNeutral: false,\r\n            attackerAnswer: null,\r\n            defenderAnswer: null,\r\n            responseOrder: [],\r\n            isCapital: true,\r\n            consecutiveWins: newConsecutiveWins,\r\n            requiredWins: state.requiredWins,\r\n            currentTask: nextTask,\r\n            capitalTasks: state.capitalTasks,\r\n          });\r\n          return; // Keep modal open for next encounter\r\n        }\r\n        // If we reach here, attacker has won 3 times - continue to capture\r\n      } else if (state.isCapital && winner === 'defender') {\r\n        // Defender won, capital defense successful - close modal and end turn\r\n        // Award 100 points to defender for successful defense\r\n        newTeams[zoneOwnerId].score += 100;\r\n        setTeams(newTeams);\r\n\r\n        setPendingCaptureZone(null);\r\n        setCaptureState({\r\n          attackerAnswered: false,\r\n          defenderAnswered: false,\r\n          attackerCorrect: null,\r\n          defenderCorrect: null,\r\n          firstResponder: null,\r\n          isNeutral: false,\r\n          attackerAnswer: null,\r\n          defenderAnswer: null,\r\n          responseOrder: [],\r\n          isCapital: false,\r\n          consecutiveWins: 0,\r\n          requiredWins: 3,\r\n          currentTask: null,\r\n          capitalTasks: [],\r\n        });\r\n        onTurnComplete();\r\n        return;\r\n      }\r\n\r\n      if (winner === 'attacker' && zoneOwnerId !== activeTeam) {\r\n        if (zoneOwner.base === zoneId) {\r\n          newTeams[activeTeam].score += 400;\r\n\r\n          // Capture all zones of the defeated team\r\n          const zonesToCapture = [...newTeams[zoneOwnerId].zones];\r\n          zonesToCapture.forEach((zone) => {\r\n            if (zone !== zoneId) {\r\n              // Remove from defeated team\r\n              newTeams[zoneOwnerId].zones = newTeams[zoneOwnerId].zones.filter(z => z !== zone);\r\n              // Add to attacker team\r\n              if (!newTeams[activeTeam].zones.includes(zone)) {\r\n                newTeams[activeTeam].zones.push(zone);\r\n              }\r\n            }\r\n          });\r\n\r\n          // Remove base from defeated team\r\n          newTeams[zoneOwnerId].base = null;\r\n\r\n          // Capture the base zone\r\n          newTeams[zoneOwnerId].zones = newTeams[zoneOwnerId].zones.filter(z => z !== zoneId);\r\n          newTeams[activeTeam].zones.push(zoneId);\r\n          newTeams[activeTeam].base = zoneId;\r\n        } else {\r\n          newTeams[activeTeam].score += 100;\r\n          // Remove from defender and add to attacker\r\n          newTeams[zoneOwnerId].zones = newTeams[zoneOwnerId].zones.filter(z => z !== zoneId);\r\n          newTeams[activeTeam].zones.push(zoneId);\r\n        }\r\n      } else if (winner === 'defender') {\r\n        // Defender successfully defended - award 100 points\r\n        newTeams[zoneOwnerId].score += 100;\r\n      }\r\n\r\n      setTeams(newTeams);\r\n      setPendingCaptureZone(null);\r\n      setCaptureState({\r\n        attackerAnswered: false,\r\n        defenderAnswered: false,\r\n        attackerCorrect: null,\r\n        defenderCorrect: null,\r\n        firstResponder: null,\r\n        isNeutral: false,\r\n        attackerAnswer: null,\r\n        defenderAnswer: null,\r\n        responseOrder: [],\r\n        isCapital: false,\r\n        consecutiveWins: 0,\r\n        requiredWins: 3,\r\n        currentTask: null,\r\n        capitalTasks: [],\r\n      });\r\n      onTurnComplete();\r\n    },\r\n    [activeTeam, onTurnComplete, teams, recordAction]\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (\r\n      pendingCaptureZone &&\r\n      !captureState.isNeutral &&\r\n      captureState.attackerAnswered &&\r\n      captureState.defenderAnswered\r\n    ) {\r\n      maybeResolveCapture(captureState, pendingCaptureZone);\r\n    }\r\n  }, [captureState, pendingCaptureZone, maybeResolveCapture]);\r\n\r\n  const handleAttackerAnswer = React.useCallback(\r\n    (isCorrect) => {\r\n      if (!pendingCaptureZone) return;\r\n\r\n      // Для вражеских территорий - переключаем выбор\r\n      setCaptureState((prev) => {\r\n        // Если уже выбран этот вариант - отменяем выбор\r\n        if (prev.attackerAnswer === isCorrect) {\r\n          return {\r\n            ...prev,\r\n            attackerAnswer: null,\r\n            attackerAnswered: false,\r\n            responseOrder: prev.responseOrder.filter(item => item !== 'attacker')\r\n          };\r\n        }\r\n\r\n        const newResponseOrder = [...prev.responseOrder];\r\n        if (!newResponseOrder.includes('attacker')) {\r\n          newResponseOrder.push('attacker');\r\n        }\r\n\r\n        const next = {\r\n          ...prev,\r\n          attackerAnswer: isCorrect,\r\n          attackerAnswered: true,\r\n          attackerCorrect: isCorrect,\r\n          responseOrder: newResponseOrder,\r\n        };\r\n\r\n        return next;\r\n      });\r\n    },\r\n    [captureState.isNeutral, captureState.attackerAnswer, onTurnComplete, pendingCaptureZone, activeTeam, teams, recordAction]\r\n  );\r\n\r\n  const handleDefenderAnswer = React.useCallback(\r\n    (isCorrect) => {\r\n      if (!pendingCaptureZone) return;\r\n\r\n      setCaptureState((prev) => {\r\n        // Если уже выбран этот вариант - отменяем выбор\r\n        if (prev.defenderAnswer === isCorrect) {\r\n          return {\r\n            ...prev,\r\n            defenderAnswer: null,\r\n            defenderAnswered: false,\r\n            responseOrder: prev.responseOrder.filter(item => item !== 'defender')\r\n          };\r\n        }\r\n\r\n        const newResponseOrder = [...prev.responseOrder];\r\n        if (!newResponseOrder.includes('defender')) {\r\n          newResponseOrder.push('defender');\r\n        }\r\n\r\n        const next = {\r\n          ...prev,\r\n          defenderAnswer: isCorrect,\r\n          defenderAnswered: true,\r\n          defenderCorrect: isCorrect,\r\n          responseOrder: newResponseOrder,\r\n        };\r\n\r\n        return next;\r\n      });\r\n    },\r\n    [pendingCaptureZone]\r\n  );\r\n\r\n  // Определяем порядок для отображения - теперь функция будет возвращать порядок только для активной кнопки\r\n  const getOrderForPlayer = (player, isActive) => {\r\n    if (!isActive) return '';\r\n    const index = captureState.responseOrder.indexOf(player);\r\n    return index !== -1 ? (index + 1).toString() : '';\r\n  };\r\n\r\n  return (\r\n    <GameContainer>\r\n      <MapWrapper>\r\n        <Map\r\n          teams={teams}\r\n          basePositions={basePositions}\r\n          gameState={gameState}\r\n          disabledZones={\r\n            gameState === 'prepare' && activeTeam !== null\r\n              ? map.getAdjucentZones(\r\n                teams.filter((_, index) => index !== activeTeam).flatMap((team) => team.zones)\r\n              )\r\n              : []\r\n          }\r\n          onZoneClick={onZoneClick}\r\n        />\r\n\r\n        {/* Кнопки Undo/Redo */}\r\n        <UndoButton\r\n          disabled={history.length === 0}\r\n          onClick={undo}\r\n          title=\"Отменить последнее действие\"\r\n        >\r\n          <img src=\"/test/images/undo-icon.png\" alt=\"Отменить\" />\r\n        </UndoButton>\r\n\r\n        <RedoButton\r\n          disabled={future.length === 0}\r\n          onClick={redo}\r\n          title=\"Повторить отмененное действие\"\r\n        >\r\n          <img src=\"/test/images/redo-icon.png\" alt=\"Повторить\" />\r\n        </RedoButton>\r\n\r\n        {pendingCaptureZone && (\r\n          <CaptureModalBackdrop>\r\n            <CaptureModalCard>\r\n              {/* Left Actions (Defender) */}\r\n              <CaptureModalSideActions className=\"left\" isNeutral={false}>\r\n                <CaptureButton\r\n                  className={captureState.defenderAnswer === false ? 'active' : ''}\r\n                  onClick={() => handleDefenderAnswer(false)}\r\n                  data-order={getOrderForPlayer('defender', captureState.defenderAnswer === false)}\r\n                >\r\n                  <img src=\"/test/images/defend-wrong-icon.png\" alt=\"Защита неверно\" />\r\n                </CaptureButton>\r\n                <CaptureButton\r\n                  className={captureState.defenderAnswer === true ? 'active' : ''}\r\n                  onClick={() => handleDefenderAnswer(true)}\r\n                  data-order={getOrderForPlayer('defender', captureState.defenderAnswer === true)}\r\n                >\r\n                  <img src=\"/test/images/defend-correct-icon.png\" alt=\"Защита верно\" />\r\n                </CaptureButton>\r\n              </CaptureModalSideActions>\r\n\r\n\r\n              {/* Center Content */}\r\n              <CaptureModalContent>\r\n                <CaptureModalTitle>\r\n                  РЕГИОН {pendingCaptureZone} {captureState.isCapital && `(СТОЛИЦА ${captureState.consecutiveWins}/${captureState.requiredWins})`}\r\n                </CaptureModalTitle>\r\n                <CaptureModalText>\r\n                  {captureState.currentTask ? captureState.currentTask.text : (\r\n                    availableTasks.length > 0 && usedTaskIds.size >= availableTasks.length\r\n                      ? 'Задач нет'\r\n                      : (captureState.isCapital\r\n                        ? `Атака на столицу! Для захвата необходимо победить в ${captureState.requiredWins} схватках подряд.`\r\n                        : 'Захват вражеской территории. Здесь будет описание задания или подсказка для игрока. После выполнения задания выберите результат атаки для атакующих и защищающихся.')\r\n                  )}\r\n                </CaptureModalText>\r\n                {captureState.currentTask && captureState.currentTask.imagePath && (\r\n                  <CaptureModalImagePlaceholder>\r\n                    <img src={captureState.currentTask.imagePath} alt=\"Task illustration\" />\r\n                  </CaptureModalImagePlaceholder>\r\n                )}\r\n              </CaptureModalContent>\r\n\r\n              {/* Right Actions (Attacker) */}\r\n              <CaptureModalSideActions className=\"right\" isNeutral={false}>\r\n                <CaptureButton\r\n                  className={captureState.attackerAnswer === false ? 'active' : ''}\r\n                  onClick={() => handleAttackerAnswer(false)}\r\n                  data-order={getOrderForPlayer('attacker', captureState.attackerAnswer === false)}\r\n                >\r\n                  <img src=\"/test/images/attack-wrong-icon.png\" alt=\"Атака неверно\" />\r\n                </CaptureButton>\r\n                <CaptureButton\r\n                  className={captureState.attackerAnswer === true ? 'active' : ''}\r\n                  onClick={() => handleAttackerAnswer(true)}\r\n                  data-order={getOrderForPlayer('attacker', captureState.attackerAnswer === true)}\r\n                >\r\n                  <img src=\"/test/images/attack-correct-icon.png\" alt=\"Атака верно\" />\r\n                </CaptureButton>\r\n              </CaptureModalSideActions>\r\n            </CaptureModalCard>\r\n          </CaptureModalBackdrop>\r\n        )}\r\n      </MapWrapper>\r\n\r\n      <GameControls\r\n        teams={teams}\r\n        activeTeam={activeTeam}\r\n        pendingCaptureZone={pendingCaptureZone}\r\n        captureState={captureState}\r\n        onTeamAdded={(teamName) => {\r\n          const color = availableColors[availableColors.length - 1];\r\n          const newAvailableColors = availableColors.slice(0, -1);\r\n\r\n          recordAction();\r\n          const newTeams = [\r\n            ...teams,\r\n            {\r\n              name: teamName,\r\n              score: 1000,\r\n              zones: [],\r\n              color: color,\r\n              base: null,\r\n            },\r\n          ];\r\n          setTeams(newTeams);\r\n          setAvailableColors(newAvailableColors);\r\n        }}\r\n        onTeamClick={(teamIndex) => {\r\n          if (gameState === 'prepare') {\r\n            recordAction();\r\n            setActiveTeam(teamIndex === activeTeam ? null : teamIndex);\r\n          }\r\n        }}\r\n        onGameStart={() => {\r\n          recordAction();\r\n          setGameState('started');\r\n          setCurrentTurn(0);\r\n          setRoundNumber(1);\r\n          setTurnsOrder(teams.map((tmp, index) => index));\r\n          setActiveTeam(0);\r\n        }}\r\n        onTurnComplete={() => {\r\n          recordAction();\r\n          onTurnComplete();\r\n        }}\r\n        gameState={gameState}\r\n        currentTurn={turnsOrder[currentTurn]}\r\n        roundNumber={roundNumber}\r\n      />\r\n    </GameContainer >\r\n  );\r\n};\r\n\r\nexport default Game;\r\n"],"mappings":"qeAAA,MAAO,GAAK,CAAAA,KAAK,KAAM,OAAO,CAC9B,MAAO,CAAAC,MAAM,KAAM,mBAAmB,CACtC,MAAO,CAAAC,YAAY,KAAM,iBAAiB,CAC1C,MAAO,CAAAC,GAAG,KAAM,OAAO,CACvB,OAASC,YAAY,KAAQ,gBAAgB,CAAC,OAAAC,GAAA,IAAAC,IAAA,CAAAC,IAAA,IAAAC,KAAA,yBAE9C,KAAM,CAAAC,aAAa,CAAGR,MAAM,CAACS,GAAG,CAAAC,eAAA,GAAAA,eAAA,CAAAC,sBAAA,iHAM/B,CAED,KAAM,CAAAC,UAAU,CAAGZ,MAAM,CAACS,GAAG,CAAAI,gBAAA,GAAAA,gBAAA,CAAAF,sBAAA,iHAM5B,CAED,KAAM,CAAAG,oBAAoB,CAAGd,MAAM,CAACS,GAAG,CAAAM,gBAAA,GAAAA,gBAAA,CAAAJ,sBAAA,2LAStC,CAED,KAAM,CAAAK,gBAAgB,CAAGhB,MAAM,CAACS,GAAG,CAAAQ,gBAAA,GAAAA,gBAAA,CAAAN,sBAAA,+VAgBlC,CAED,KAAM,CAAAO,mBAAmB,CAAGlB,MAAM,CAACS,GAAG,CAAAU,gBAAA,GAAAA,gBAAA,CAAAR,sBAAA,oIAOrC,CAED,KAAM,CAAAS,4BAA4B,CAAGpB,MAAM,CAACS,GAAG,CAAAY,gBAAA,GAAAA,gBAAA,CAAAV,sBAAA,yZAsB9C,CAED,KAAM,CAAAW,iBAAiB,CAAGtB,MAAM,CAACuB,EAAE,CAAAC,gBAAA,GAAAA,gBAAA,CAAAb,sBAAA,yGAKlC,CAED,KAAM,CAAAc,gBAAgB,CAAGzB,MAAM,CAAC0B,CAAC,CAAAC,gBAAA,GAAAA,gBAAA,CAAAhB,sBAAA,6GAMhC,CAED,KAAM,CAAAiB,uBAAuB,CAAG5B,MAAM,CAACS,GAAG,CAAAoB,gBAAA,GAAAA,gBAAA,CAAAlB,sBAAA,qPAIrBmB,KAAK,EAAIA,KAAK,CAACC,SAAS,CAAG,eAAe,CAAG,UAAU,CAY3E,CAED,KAAM,CAAAC,aAAa,CAAGhC,MAAM,CAACiC,MAAM,CAAAC,gBAAA,GAAAA,gBAAA,CAAAvB,sBAAA,01BA6BpBmB,KAAK,EAAIA,KAAK,CAAC,YAAY,CAAC,CAAG,CAAC,CAAG,CAAC,CAiBlD,CAED,KAAM,CAAAK,YAAY,CAAGnC,MAAM,CAACiC,MAAM,CAAAG,gBAAA,GAAAA,gBAAA,CAAAzB,sBAAA,ydAOtBmB,KAAK,EAAIA,KAAK,CAACO,QAAQ,CAAG,aAAa,CAAG,SAAS,CAI/CP,KAAK,EAAIA,KAAK,CAACO,QAAQ,CAAG,MAAM,CAAG,SAAS,CAC/CP,KAAK,EAAIA,KAAK,CAACO,QAAQ,CAAG,GAAG,CAAG,CAAC,CAa7C,CAED,KAAM,CAAAC,UAAU,CAAGtC,MAAM,CAACmC,YAAY,CAAC,CAAAI,iBAAA,GAAAA,iBAAA,CAAA5B,sBAAA,yBAEtC,CAED,KAAM,CAAA6B,UAAU,CAAGxC,MAAM,CAACmC,YAAY,CAAC,CAAAM,iBAAA,GAAAA,iBAAA,CAAA9B,sBAAA,0BAEtC,CAED,KAAM,CAAA+B,iBAAiB,CAAIC,GAAG,EAAKA,GAAG,CAACC,MAAM,CAACD,GAAG,CAACE,MAAM,CAAC,CAAC,CAAE,CAAC,CAAC,CAAC,CAE/D,KAAM,CAAAC,aAAa,CAAG3C,YAAY,CAAC,CACjC,SAAS,CACT,SAAS,CACT,SAAS,CACT,SAAS,CACT,SAAS,CACT,SAAS,CACT,SAAS,CACV,CAAC,CAEF,KAAM,CAAA4C,IAAI,CAAGC,IAAA,EAAa,IAAZ,CAAEC,GAAI,CAAC,CAAAD,IAAA,CACnB,KAAM,CAACE,KAAK,CAAEC,QAAQ,CAAC,CAAGpD,KAAK,CAACqD,QAAQ,CAAC,EAAE,CAAC,CAC5C,KAAM,CAACC,SAAS,CAAEC,YAAY,CAAC,CAAGvD,KAAK,CAACqD,QAAQ,CAAC,SAAS,CAAC,CAC3D,KAAM,CAACG,UAAU,CAAEC,aAAa,CAAC,CAAGzD,KAAK,CAACqD,QAAQ,CAAC,EAAE,CAAC,CACtD,KAAM,CAACK,WAAW,CAAEC,cAAc,CAAC,CAAG3D,KAAK,CAACqD,QAAQ,CAAC,IAAI,CAAC,CAC1D,KAAM,CAACO,WAAW,CAAEC,cAAc,CAAC,CAAG7D,KAAK,CAACqD,QAAQ,CAAC,CAAC,CAAC,CACvD,KAAM,CAACS,UAAU,CAAEC,aAAa,CAAC,CAAG/D,KAAK,CAACqD,QAAQ,CAAC,IAAI,CAAC,CACxD,KAAM,CAACW,kBAAkB,CAAEC,qBAAqB,CAAC,CAAGjE,KAAK,CAACqD,QAAQ,CAAC,IAAI,CAAC,CACxE,KAAM,CAACa,YAAY,CAAEC,eAAe,CAAC,CAAGnE,KAAK,CAACqD,QAAQ,CAAC,CACrDe,gBAAgB,CAAE,KAAK,CACvBC,gBAAgB,CAAE,KAAK,CACvBC,eAAe,CAAE,IAAI,CACrBC,eAAe,CAAE,IAAI,CACrBC,cAAc,CAAE,IAAI,CACpBxC,SAAS,CAAE,KAAK,CAChByC,cAAc,CAAE,IAAI,CACpBC,cAAc,CAAE,IAAI,CACpBC,aAAa,CAAE,EAAE,CACjBC,SAAS,CAAE,KAAK,CAChBC,eAAe,CAAE,CAAC,CAClBC,YAAY,CAAE,CAAC,CACfC,WAAW,CAAE,IAAI,CACjBC,YAAY,CAAE,EAChB,CAAC,CAAC,CAEF,KAAM,CAACC,cAAc,CAAEC,iBAAiB,CAAC,CAAGlF,KAAK,CAACqD,QAAQ,CAAC,EAAE,CAAC,CAE9D,KAAM,CAAC8B,eAAe,CAAEC,kBAAkB,CAAC,CAAGpF,KAAK,CAACqD,QAAQ,CAAC,CAAC,GAAGN,aAAa,CAAC,CAAC,CAChF,KAAM,CAACsC,WAAW,CAAEC,cAAc,CAAC,CAAGtF,KAAK,CAACqD,QAAQ,CAAC,GAAI,CAAAkC,GAAG,CAAC,CAAC,CAAC,CAE/D;AACAvF,KAAK,CAACwF,SAAS,CAAC,IAAM,CACpB,KAAM,CAAAC,SAAS,CAAG,KAAAA,CAAA,GAAY,CAC5B,GAAI,CACF,KAAM,CAAAC,KAAK,CAAG,EAAE,CAChB,GAAI,CAAAC,UAAU,CAAG,CAAC,CAElB;AACA,MAAOA,UAAU,EAAI,GAAG,CAAE,CACxB,GAAI,CACF;AACA,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAC,KAAK,gBAAAhD,MAAA,CAAgB8C,UAAU,QAAM,CAAC,CAC7D,GAAI,CAACC,QAAQ,CAACE,EAAE,CAAE,MAElB,KAAM,CAAAC,IAAI,CAAG,KAAM,CAAAH,QAAQ,CAACG,IAAI,CAAC,CAAC,CAElC;AACA,GAAIA,IAAI,CAACC,IAAI,CAAC,CAAC,CAACC,UAAU,CAAC,WAAW,CAAC,EAAIF,IAAI,CAACC,IAAI,CAAC,CAAC,CAACC,UAAU,CAAC,OAAO,CAAC,CAAE,CAC1E,MAAO;AACT,CAEA;AACA,GAAI,CAAAC,QAAQ,CAAG,KAAK,CACpB,GAAI,CACF,KAAM,CAAAC,WAAW,CAAG,KAAM,CAAAN,KAAK,qBAAAhD,MAAA,CAAqB8C,UAAU,SAAQ,CAAES,MAAM,CAAE,MAAO,CAAC,CAAC,CACzF,GAAID,WAAW,CAACL,EAAE,CAAE,CAClB,KAAM,CAAAO,WAAW,CAAGF,WAAW,CAACG,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC,CAC3D;AACA,GAAI,CAACF,WAAW,EAAIA,WAAW,CAACJ,UAAU,CAAC,QAAQ,CAAC,CAAE,CACpDC,QAAQ,CAAG,IAAI,CACjB,CACF,CACF,CAAE,MAAOM,CAAC,CAAE,CACVC,OAAO,CAACC,IAAI,CAAC,uBAAuB,CAAEF,CAAC,CAAC,CAC1C,CAEAd,KAAK,CAACiB,IAAI,CAAC,CACTC,EAAE,CAAEjB,UAAU,CACdI,IAAI,CAAEA,IAAI,CAACC,IAAI,CAAC,CAAC,CACjBa,SAAS,CAAEX,QAAQ,qBAAArD,MAAA,CAAuB8C,UAAU,SAAS,IAC/D,CAAC,CAAC,CAEFA,UAAU,EAAE,CACd,CAAE,MAAOmB,KAAK,CAAE,CACd,MACF,CACF,CAEA5B,iBAAiB,CAACQ,KAAK,CAAC,CAC1B,CAAE,MAAOoB,KAAK,CAAE,CACdL,OAAO,CAACK,KAAK,CAAC,sBAAsB,CAAEA,KAAK,CAAC,CAC9C,CACF,CAAC,CAEDrB,SAAS,CAAC,CAAC,CACb,CAAC,CAAE,EAAE,CAAC,CAEN;AACA,KAAM,CAAAsB,iBAAiB,CAAG/G,KAAK,CAACgH,WAAW,CAAEC,KAAK,EAAK,CACrD;AACA,KAAM,CAAAC,WAAW,CAAGjC,cAAc,CAACkC,MAAM,CAACC,IAAI,EAAI,CAAC/B,WAAW,CAACgC,GAAG,CAACD,IAAI,CAACR,EAAE,CAAC,CAAC,CAE5E,GAAIM,WAAW,CAACI,MAAM,GAAK,CAAC,CAAE,MAAO,EAAE,CAEvC,KAAM,CAAAC,QAAQ,CAAG,CAAC,GAAGL,WAAW,CAAC,CAACM,IAAI,CAAC,IAAMC,IAAI,CAACC,MAAM,CAAC,CAAC,CAAG,GAAG,CAAC,CACjE,MAAO,CAAAH,QAAQ,CAACI,KAAK,CAAC,CAAC,CAAEF,IAAI,CAACG,GAAG,CAACX,KAAK,CAAEC,WAAW,CAACI,MAAM,CAAC,CAAC,CAC/D,CAAC,CAAE,CAACrC,cAAc,CAAEI,WAAW,CAAC,CAAC,CAEjC;AACA,KAAM,CAACwC,OAAO,CAAEC,UAAU,CAAC,CAAG9H,KAAK,CAACqD,QAAQ,CAAC,EAAE,CAAC,CAChD,KAAM,CAAC0E,MAAM,CAAEC,SAAS,CAAC,CAAGhI,KAAK,CAACqD,QAAQ,CAAC,EAAE,CAAC,CAE9C,KAAM,CAAA4E,YAAY,CAAGjI,KAAK,CAACgH,WAAW,CAAC,IAAM,CAC3C,KAAM,CAAAkB,YAAY,CAAG,CACnB/E,KAAK,CAAEgF,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAAClF,KAAK,CAAC,CAAC,CACxCG,SAAS,CACTE,UAAU,CAAE,CAAC,GAAGA,UAAU,CAAC,CAC3BE,WAAW,CACXE,WAAW,CACXE,UAAU,CACVqB,eAAe,CAAE,CAAC,GAAGA,eAAe,CAAC,CACrCE,WAAW,CAAE,GAAI,CAAAE,GAAG,CAACF,WAAW,CAAC,CACjCrB,kBAAkB,CAClBE,YAAY,CAAEiE,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACnE,YAAY,CAAC,CACvD,CAAC,CACD4D,UAAU,CAAEQ,IAAI,EAAK,CAAC,GAAGA,IAAI,CAAEJ,YAAY,CAAC,CAAC,CAC7CF,SAAS,CAAC,EAAE,CAAC,CACf,CAAC,CAAE,CAAC7E,KAAK,CAAEG,SAAS,CAAEE,UAAU,CAAEE,WAAW,CAAEE,WAAW,CAAEE,UAAU,CAAEqB,eAAe,CAAEE,WAAW,CAAErB,kBAAkB,CAAEE,YAAY,CAAC,CAAC,CAExI,KAAM,CAAAqE,YAAY,CAAGvI,KAAK,CAACgH,WAAW,CAAEwB,KAAK,EAAK,CAChDpF,QAAQ,CAACoF,KAAK,CAACrF,KAAK,CAAC,CACrBI,YAAY,CAACiF,KAAK,CAAClF,SAAS,CAAC,CAC7BG,aAAa,CAAC+E,KAAK,CAAChF,UAAU,CAAC,CAC/BG,cAAc,CAAC6E,KAAK,CAAC9E,WAAW,CAAC,CACjCG,cAAc,CAAC2E,KAAK,CAAC5E,WAAW,CAAC,CACjCG,aAAa,CAACyE,KAAK,CAAC1E,UAAU,CAAC,CAC/BsB,kBAAkB,CAACoD,KAAK,CAACrD,eAAe,CAAC,CACzCG,cAAc,CAACkD,KAAK,CAACnD,WAAW,EAAI,GAAI,CAAAE,GAAG,CAAC,CAAC,CAAC,CAE9C;AACAtB,qBAAqB,CAACuE,KAAK,CAACxE,kBAAkB,EAAI,IAAI,CAAC,CAEvD;AACA;AACA,GAAIwE,KAAK,CAACtE,YAAY,CAAE,CACtBC,eAAe,CAAAsE,aAAA,CAAAA,aAAA,IACVD,KAAK,CAACtE,YAAY,MACrBE,gBAAgB,CAAE,KAAK,CACvBC,gBAAgB,CAAE,KAAK,CACvBC,eAAe,CAAE,IAAI,CACrBC,eAAe,CAAE,IAAI,CACrBE,cAAc,CAAE,IAAI,CACpBC,cAAc,CAAE,IAAI,CACpBC,aAAa,CAAE,EAAE,EAClB,CAAC,CACJ,CAAC,IAAM,CACLR,eAAe,CAAC,CACdC,gBAAgB,CAAE,KAAK,CACvBC,gBAAgB,CAAE,KAAK,CACvBC,eAAe,CAAE,IAAI,CACrBC,eAAe,CAAE,IAAI,CACrBC,cAAc,CAAE,IAAI,CACpBxC,SAAS,CAAE,KAAK,CAChByC,cAAc,CAAE,IAAI,CACpBC,cAAc,CAAE,IAAI,CACpBC,aAAa,CAAE,EAAE,CACjBC,SAAS,CAAE,KAAK,CAChBC,eAAe,CAAE,CAAC,CAClBC,YAAY,CAAE,CAAC,CACfC,WAAW,CAAE,IAAI,CACjBC,YAAY,CAAE,EAChB,CAAC,CAAC,CACJ,CACF,CAAC,CAAE,EAAE,CAAC,CAEN,KAAM,CAAA0D,IAAI,CAAG1I,KAAK,CAACgH,WAAW,CAAC,IAAM,CACnC;AACA,GAAIhD,kBAAkB,GAAK,IAAI,CAAE,CAC/B;AACA,GAAIE,YAAY,CAACU,SAAS,EAAIV,YAAY,CAACW,eAAe,CAAG,CAAC,CAAE,CAC9D;AACA,KAAM,CAAA8D,YAAY,CAAGzE,YAAY,CAACW,eAAe,CAAG,CAAC,CACrD,KAAM,CAAA+D,YAAY,CAAG1E,YAAY,CAACc,YAAY,CAAC2D,YAAY,CAAC,EAAIzE,YAAY,CAACc,YAAY,CAAC,CAAC,CAAC,CAE5Fb,eAAe,CAAAsE,aAAA,CAAAA,aAAA,IACVvE,YAAY,MACfW,eAAe,CAAE8D,YAAY,CAC7B5D,WAAW,CAAE6D,YAAY,CACzBxE,gBAAgB,CAAE,KAAK,CACvBC,gBAAgB,CAAE,KAAK,CACvBC,eAAe,CAAE,IAAI,CACrBC,eAAe,CAAE,IAAI,CACrBE,cAAc,CAAE,IAAI,CACpBC,cAAc,CAAE,IAAI,CACpBC,aAAa,CAAE,EAAE,EAClB,CAAC,CACF,OACF,CAEA;AACA;AACA,KAAM,CAAAkE,mBAAmB,CAAG,CAC1B1F,KAAK,CAAEgF,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAAClF,KAAK,CAAC,CAAC,CACxCG,SAAS,CACTE,UAAU,CAAE,CAAC,GAAGA,UAAU,CAAC,CAC3BE,WAAW,CACXE,WAAW,CACXE,UAAU,CACVqB,eAAe,CAAE,CAAC,GAAGA,eAAe,CAAC,CACrCE,WAAW,CAAE,GAAI,CAAAE,GAAG,CAACF,WAAW,CAAC,CACjCrB,kBAAkB,CAClBE,YAAY,CAAEiE,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACnE,YAAY,CAAC,CACvD,CAAC,CAED8D,SAAS,CAAEM,IAAI,EAAK,CAACO,mBAAmB,CAAE,GAAGP,IAAI,CAAC,CAAC,CAEnDrE,qBAAqB,CAAC,IAAI,CAAC,CAC3BE,eAAe,CAAC,CACdC,gBAAgB,CAAE,KAAK,CACvBC,gBAAgB,CAAE,KAAK,CACvBC,eAAe,CAAE,IAAI,CACrBC,eAAe,CAAE,IAAI,CACrBC,cAAc,CAAE,IAAI,CACpBxC,SAAS,CAAE,KAAK,CAChByC,cAAc,CAAE,IAAI,CACpBC,cAAc,CAAE,IAAI,CACpBC,aAAa,CAAE,EAAE,CACjBC,SAAS,CAAE,KAAK,CAChBC,eAAe,CAAE,CAAC,CAClBC,YAAY,CAAE,CAAC,CACfC,WAAW,CAAE,IAAI,CACjBC,YAAY,CAAE,EAChB,CAAC,CAAC,CAEF;AACA;AACA,GAAI6C,OAAO,CAACP,MAAM,CAAG,CAAC,CAAE,CACtB,KAAM,CAAAwB,SAAS,CAAGjB,OAAO,CAACA,OAAO,CAACP,MAAM,CAAG,CAAC,CAAC,CAC7C,GAAIwB,SAAS,CAACzD,WAAW,CAAE,CACzBC,cAAc,CAACwD,SAAS,CAACzD,WAAW,CAAC,CACvC,CACF,CACA,OACF,CAEA,GAAIwC,OAAO,CAACP,MAAM,GAAK,CAAC,CAAE,OAE1B,KAAM,CAAAyB,aAAa,CAAGlB,OAAO,CAACA,OAAO,CAACP,MAAM,CAAG,CAAC,CAAC,CACjD,KAAM,CAAA0B,UAAU,CAAGnB,OAAO,CAACF,KAAK,CAAC,CAAC,CAAE,CAAC,CAAC,CAAC,CAEvC,KAAM,CAAAO,YAAY,CAAG,CACnB/E,KAAK,CAAEgF,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAAClF,KAAK,CAAC,CAAC,CACxCG,SAAS,CACTE,UAAU,CAAE,CAAC,GAAGA,UAAU,CAAC,CAC3BE,WAAW,CACXE,WAAW,CACXE,UAAU,CACVqB,eAAe,CAAE,CAAC,GAAGA,eAAe,CAAC,CACrCE,WAAW,CAAE,GAAI,CAAAE,GAAG,CAACF,WAAW,CAAC,CACjCrB,kBAAkB,CAClBE,YAAY,CAAEiE,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACnE,YAAY,CAAC,CACvD,CAAC,CAED8D,SAAS,CAAEM,IAAI,EAAK,CAACJ,YAAY,CAAE,GAAGI,IAAI,CAAC,CAAC,CAC5CR,UAAU,CAACkB,UAAU,CAAC,CACtBT,YAAY,CAACQ,aAAa,CAAC,CAC7B,CAAC,CAAE,CAAClB,OAAO,CAAE1E,KAAK,CAAEG,SAAS,CAAEE,UAAU,CAAEE,WAAW,CAAEE,WAAW,CAAEE,UAAU,CAAEqB,eAAe,CAAEE,WAAW,CAAErB,kBAAkB,CAAEE,YAAY,CAAEqE,YAAY,CAAC,CAAC,CAE/J,KAAM,CAAAU,IAAI,CAAGjJ,KAAK,CAACgH,WAAW,CAAC,IAAM,CACnC,GAAIe,MAAM,CAACT,MAAM,GAAK,CAAC,CAAE,OAEzB,KAAM,CAAA4B,SAAS,CAAGnB,MAAM,CAAC,CAAC,CAAC,CAC3B,KAAM,CAAAoB,SAAS,CAAGpB,MAAM,CAACJ,KAAK,CAAC,CAAC,CAAC,CAEjC;AACA,KAAM,CAAAO,YAAY,CAAG,CACnB/E,KAAK,CAAEgF,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAAClF,KAAK,CAAC,CAAC,CACxCG,SAAS,CACTE,UAAU,CAAE,CAAC,GAAGA,UAAU,CAAC,CAC3BE,WAAW,CACXE,WAAW,CACXE,UAAU,CACVqB,eAAe,CAAE,CAAC,GAAGA,eAAe,CAAC,CACrCE,WAAW,CAAE,GAAI,CAAAE,GAAG,CAACF,WAAW,CAAC,CACjCrB,kBAAkB,CAClBE,YAAY,CAAEiE,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACnE,YAAY,CAAC,CACvD,CAAC,CAED4D,UAAU,CAAEQ,IAAI,EAAK,CAAC,GAAGA,IAAI,CAAEJ,YAAY,CAAC,CAAC,CAC7CF,SAAS,CAACmB,SAAS,CAAC,CACpBZ,YAAY,CAACW,SAAS,CAAC,CACzB,CAAC,CAAE,CAACnB,MAAM,CAAE5E,KAAK,CAAEG,SAAS,CAAEE,UAAU,CAAEE,WAAW,CAAEE,WAAW,CAAEE,UAAU,CAAEqB,eAAe,CAAEE,WAAW,CAAErB,kBAAkB,CAAEE,YAAY,CAAEqE,YAAY,CAAC,CAAC,CAE9J;AACA,KAAM,CAAAa,aAAa,CAAGpJ,KAAK,CAACqJ,OAAO,CAAC,IAAM,CACxC,MAAO,CAAAlG,KAAK,CAACD,GAAG,CAACoG,IAAI,EAAIA,IAAI,CAACC,IAAI,CAAC,CAACpC,MAAM,CAACqC,OAAO,CAAC,CACrD,CAAC,CAAE,CAACrG,KAAK,CAAC,CAAC,CAEX,KAAM,CAAAsG,OAAO,CAAGzJ,KAAK,CAACgH,WAAW,CAC/B,CAAC0C,MAAM,CAAEC,SAAS,GAAK,CACrB,KAAM,CAAAC,QAAQ,CAAG,CAAC,GAAGzG,KAAK,CAAC,CAC3ByG,QAAQ,CAACD,SAAS,CAAC,CAACJ,IAAI,CAAGG,MAAM,CACjCtG,QAAQ,CAACwG,QAAQ,CAAC,CACpB,CAAC,CACD,CAACzG,KAAK,CACR,CAAC,CAED,KAAM,CAAA0G,gBAAgB,CAAG7J,KAAK,CAACgH,WAAW,CACxC,CAAC0C,MAAM,CAAEC,SAAS,GAAK,CACrB,KAAM,CAAAC,QAAQ,CAAG,CAAC,GAAGzG,KAAK,CAAC,CAE3B;AACA,KAAM,CAAA2G,kBAAkB,CAAGF,QAAQ,CAACD,SAAS,CAAC,CAACI,KAAK,CAACC,QAAQ,CAACN,MAAM,CAAC,CAErE,GAAII,kBAAkB,CAAE,CACtB;AACAF,QAAQ,CAACD,SAAS,CAAC,CAACI,KAAK,CAAGH,QAAQ,CAACD,SAAS,CAAC,CAACI,KAAK,CAAC5C,MAAM,CAAE8C,CAAC,EAAKA,CAAC,GAAKP,MAAM,CAAC,CAEjF;AACA,GAAIE,QAAQ,CAACD,SAAS,CAAC,CAACJ,IAAI,GAAKG,MAAM,CAAE,CACvCE,QAAQ,CAACD,SAAS,CAAC,CAACJ,IAAI,CAAG,IAAI,CACjC,CACF,CAAC,IAAM,CACL;AACA,IAAK,GAAI,CAAAW,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGN,QAAQ,CAACtC,MAAM,CAAE4C,CAAC,EAAE,CAAE,CACxC,GAAIN,QAAQ,CAACM,CAAC,CAAC,CAACH,KAAK,CAACC,QAAQ,CAACN,MAAM,CAAC,CAAE,CACtCE,QAAQ,CAACM,CAAC,CAAC,CAACH,KAAK,CAAGH,QAAQ,CAACM,CAAC,CAAC,CAACH,KAAK,CAAC5C,MAAM,CAAE8C,CAAC,EAAKA,CAAC,GAAKP,MAAM,CAAC,CAEjE;AACA,GAAIE,QAAQ,CAACM,CAAC,CAAC,CAACX,IAAI,GAAKG,MAAM,CAAE,CAC/BE,QAAQ,CAACM,CAAC,CAAC,CAACX,IAAI,CAAG,IAAI,CACzB,CACA,MACF,CACF,CAEA;AACAK,QAAQ,CAACD,SAAS,CAAC,CAACI,KAAK,CAACpD,IAAI,CAAC+C,MAAM,CAAC,CAEtC;AACA,GAAIpG,SAAS,GAAK,SAAS,EAAI,CAACsG,QAAQ,CAACD,SAAS,CAAC,CAACJ,IAAI,CAAE,CACxDK,QAAQ,CAACD,SAAS,CAAC,CAACJ,IAAI,CAAGG,MAAM,CACnC,CACF,CAEAtG,QAAQ,CAACwG,QAAQ,CAAC,CACpB,CAAC,CACD,CAACzG,KAAK,CAAEG,SAAS,CACnB,CAAC,CAED,KAAM,CAAA6G,cAAc,CAAGnK,KAAK,CAACgH,WAAW,CAAC,IAAM,CAC7C,KAAM,CAAAoD,QAAQ,CAAG5G,UAAU,CACxBmE,KAAK,CAACjE,WAAW,CAAG,CAAC,CAAC,CACtB2G,IAAI,CAAEV,SAAS,EAAKxG,KAAK,CAACwG,SAAS,CAAC,CAACI,KAAK,CAACzC,MAAM,CAAG,CAAC,CAAC,CAEzD,GAAI,MAAO,CAAA8C,QAAQ,GAAK,WAAW,CAAE,CACnCzG,cAAc,CAACD,WAAW,CAAG,CAAC,CAAC,CAC/BK,aAAa,CAACqG,QAAQ,CAAC,CACvB,OACF,CAEAvG,cAAc,CAACD,WAAW,CAAG,CAAC,CAAC,CAC/BD,cAAc,CAAC,CAAC,CAAC,CAEjB,KAAM,CAAA2G,aAAa,CAAG3H,iBAAiB,CACrC,CAAC,GAAGa,UAAU,CAAC,CACZN,GAAG,CAAEyG,SAAS,EAAMxG,KAAK,CAACwG,SAAS,CAAC,CAACI,KAAK,CAACzC,MAAM,CAAG,CAAC,CAAGqC,SAAS,CAAGY,SAAU,CAAC,CAC/EpD,MAAM,CAAE+C,CAAC,EAAK,MAAO,CAAAA,CAAC,GAAK,WAAW,CAC3C,CAAC,CAEDzG,aAAa,CAAC6G,aAAa,CAAC,CAC5BvG,aAAa,CAACuG,aAAa,CAAC,CAAC,CAAC,CAAC,CACjC,CAAC,CAAE,CAAC5G,WAAW,CAAEE,WAAW,CAAET,KAAK,CAAEK,UAAU,CAAC,CAAC,CAEjD,KAAM,CAAAgH,WAAW,CAAGxK,KAAK,CAACgH,WAAW,CACnC,CAAC0C,MAAM,CAAEe,YAAY,GAAK,CACxB,GAAInH,SAAS,GAAK,SAAS,EAAIQ,UAAU,GAAK,IAAI,CAAE,CAClDmE,YAAY,CAAC,CAAC,CACd4B,gBAAgB,CAACH,MAAM,CAAE5F,UAAU,CAAC,CACtC,CACA,GAAIR,SAAS,GAAK,SAAS,CAAE,CAC3B;AACA,GAAImH,YAAY,CAAE,OAElB,KAAM,CAAAC,SAAS,CAAGvH,KAAK,CAACkH,IAAI,CAAEf,IAAI,EAAKA,IAAI,CAACS,KAAK,CAACC,QAAQ,CAACN,MAAM,CAAC,CAAC,CACnE,KAAM,CAAAiB,WAAW,CAAGxH,KAAK,CAACyH,SAAS,CAAEtB,IAAI,EAAKA,IAAI,CAACS,KAAK,CAACC,QAAQ,CAACN,MAAM,CAAC,CAAC,CAE1E;AACA,GAAI,CAACgB,SAAS,CAAE,CACd,OACF,CAEA;AACA,GAAIC,WAAW,GAAK7G,UAAU,CAAE,CAC9B,OACF,CAEA;AACA,KAAM,CAAAc,SAAS,CAAG8F,SAAS,CAACnB,IAAI,GAAKG,MAAM,CAE3C;AACA,GAAI,CAAAmB,aAAa,CAAG,EAAE,CACtB,GAAI,CAAA9F,WAAW,CAAG,IAAI,CAEtB,GAAIH,SAAS,CAAE,CACb;AACAiG,aAAa,CAAG9D,iBAAiB,CAAC,CAAC,CAAC,CACpChC,WAAW,CAAG8F,aAAa,CAAC,CAAC,CAAC,EAAI,IAAI,CACxC,CAAC,IAAM,CACL;AACAA,aAAa,CAAG9D,iBAAiB,CAAC,CAAC,CAAC,CACpChC,WAAW,CAAG8F,aAAa,CAAC,CAAC,CAAC,EAAI,IAAI,CACxC,CAEA;AACA,GAAIA,aAAa,CAACvD,MAAM,CAAG,CAAC,CAAE,CAC5BhC,cAAc,CAACgD,IAAI,EAAI,CACrB,KAAM,CAAAwC,IAAI,CAAG,GAAI,CAAAvF,GAAG,CAAC+C,IAAI,CAAC,CAC1BuC,aAAa,CAACE,OAAO,CAACC,CAAC,EAAIF,IAAI,CAACG,GAAG,CAACD,CAAC,CAACpE,EAAE,CAAC,CAAC,CAC1C,MAAO,CAAAkE,IAAI,CACb,CAAC,CAAC,CACJ,CAEA;AACA9C,SAAS,CAAC,EAAE,CAAC,CAEb/D,qBAAqB,CAACyF,MAAM,CAAC,CAC7BvF,eAAe,CAAC,CACdC,gBAAgB,CAAE,KAAK,CACvBC,gBAAgB,CAAE,KAAK,CACvBC,eAAe,CAAE,IAAI,CACrBC,eAAe,CAAE,IAAI,CACrBC,cAAc,CAAE,IAAI,CACpBxC,SAAS,CAAE,KAAK,CAChByC,cAAc,CAAE,IAAI,CACpBC,cAAc,CAAE,IAAI,CACpBC,aAAa,CAAE,EAAE,CACjBC,SAAS,CAAEA,SAAS,CACpBC,eAAe,CAAE,CAAC,CAClBC,YAAY,CAAE,CAAC,CACfC,WAAW,CAAEA,WAAW,CACxBC,YAAY,CAAE6F,aAChB,CAAC,CAAC,CACJ,CACF,CAAC,CACD,CAAC/G,UAAU,CAAER,SAAS,CAAE6G,cAAc,CAAEhH,KAAK,CAAE0G,gBAAgB,CAAE5B,YAAY,CAAElB,iBAAiB,CAClG,CAAC,CAED,KAAM,CAAAmE,aAAa,CAAGlL,KAAK,CAACgH,WAAW,CAAC,IAAM,CAC5C/C,qBAAqB,CAAC,IAAI,CAAC,CAC3BE,eAAe,CAAC,CACdC,gBAAgB,CAAE,KAAK,CACvBC,gBAAgB,CAAE,KAAK,CACvBC,eAAe,CAAE,IAAI,CACrBC,eAAe,CAAE,IAAI,CACrBC,cAAc,CAAE,IAAI,CACpBxC,SAAS,CAAE,KAAK,CAChByC,cAAc,CAAE,IAAI,CACpBC,cAAc,CAAE,IAAI,CACpBC,aAAa,CAAE,EACjB,CAAC,CAAC,CACJ,CAAC,CAAE,EAAE,CAAC,CAEN,KAAM,CAAAwG,mBAAmB,CAAGnL,KAAK,CAACgH,WAAW,CAC3C,CAACwB,KAAK,CAAEkB,MAAM,GAAK,CACjB,GAAI,CAAClB,KAAK,CAACpE,gBAAgB,EAAI,CAACoE,KAAK,CAACnE,gBAAgB,CAAE,OAExD,KAAM,CAAAqG,SAAS,CAAGvH,KAAK,CAACkH,IAAI,CAAEf,IAAI,EAAKA,IAAI,CAACS,KAAK,CAACC,QAAQ,CAACN,MAAM,CAAC,CAAC,CACnE,KAAM,CAAAiB,WAAW,CAAGxH,KAAK,CAACyH,SAAS,CAAEtB,IAAI,EAAKA,IAAI,CAACS,KAAK,CAACC,QAAQ,CAACN,MAAM,CAAC,CAAC,CAC1E,GAAI,CAACgB,SAAS,EAAIC,WAAW,GAAK,CAAC,CAAC,CAAE,CACpC,OACF,CAEA1C,YAAY,CAAC,CAAC,CAEd,GAAI,CAAAmD,MAAM,CAAG,UAAU,CAEvB,GAAI,CAAC5C,KAAK,CAAClE,eAAe,EAAI,CAACkE,KAAK,CAACjE,eAAe,CAAE,CACpD6G,MAAM,CAAG,UAAU,CACrB,CAAC,IAAM,IAAI5C,KAAK,CAAClE,eAAe,EAAI,CAACkE,KAAK,CAACjE,eAAe,CAAE,CAC1D6G,MAAM,CAAG,UAAU,CACrB,CAAC,IAAM,IAAI,CAAC5C,KAAK,CAAClE,eAAe,EAAIkE,KAAK,CAACjE,eAAe,CAAE,CAC1D6G,MAAM,CAAG,UAAU,CACrB,CAAC,IAAM,IAAI5C,KAAK,CAAClE,eAAe,EAAIkE,KAAK,CAACjE,eAAe,CAAE,CACzD6G,MAAM,CAAG5C,KAAK,CAAC7D,aAAa,CAAC,CAAC,CAAC,GAAK,UAAU,CAAG,UAAU,CAAG,UAAU,CAC1E,CAEA,KAAM,CAAAiF,QAAQ,CAAG,CAAC,GAAGzG,KAAK,CAAC,CAE3B;AACA,GAAIqF,KAAK,CAAC5D,SAAS,EAAIwG,MAAM,GAAK,UAAU,CAAE,CAC5C,KAAM,CAAAC,kBAAkB,CAAG7C,KAAK,CAAC3D,eAAe,CAAG,CAAC,CAEpD,GAAIwG,kBAAkB,CAAG7C,KAAK,CAAC1D,YAAY,CAAE,CAC3C;AACA;AACA,KAAM,CAAAwG,QAAQ,CAAG9C,KAAK,CAACxD,YAAY,CAACqG,kBAAkB,CAAC,EAAI7C,KAAK,CAACzD,WAAW,CAE5EZ,eAAe,CAAC,CACdC,gBAAgB,CAAE,KAAK,CACvBC,gBAAgB,CAAE,KAAK,CACvBC,eAAe,CAAE,IAAI,CACrBC,eAAe,CAAE,IAAI,CACrBC,cAAc,CAAE,IAAI,CACpBxC,SAAS,CAAE,KAAK,CAChByC,cAAc,CAAE,IAAI,CACpBC,cAAc,CAAE,IAAI,CACpBC,aAAa,CAAE,EAAE,CACjBC,SAAS,CAAE,IAAI,CACfC,eAAe,CAAEwG,kBAAkB,CACnCvG,YAAY,CAAE0D,KAAK,CAAC1D,YAAY,CAChCC,WAAW,CAAEuG,QAAQ,CACrBtG,YAAY,CAAEwD,KAAK,CAACxD,YACtB,CAAC,CAAC,CACF,OAAQ;AACV,CACA;AACF,CAAC,IAAM,IAAIwD,KAAK,CAAC5D,SAAS,EAAIwG,MAAM,GAAK,UAAU,CAAE,CACnD;AACA;AACAxB,QAAQ,CAACe,WAAW,CAAC,CAACY,KAAK,EAAI,GAAG,CAClCnI,QAAQ,CAACwG,QAAQ,CAAC,CAElB3F,qBAAqB,CAAC,IAAI,CAAC,CAC3BE,eAAe,CAAC,CACdC,gBAAgB,CAAE,KAAK,CACvBC,gBAAgB,CAAE,KAAK,CACvBC,eAAe,CAAE,IAAI,CACrBC,eAAe,CAAE,IAAI,CACrBC,cAAc,CAAE,IAAI,CACpBxC,SAAS,CAAE,KAAK,CAChByC,cAAc,CAAE,IAAI,CACpBC,cAAc,CAAE,IAAI,CACpBC,aAAa,CAAE,EAAE,CACjBC,SAAS,CAAE,KAAK,CAChBC,eAAe,CAAE,CAAC,CAClBC,YAAY,CAAE,CAAC,CACfC,WAAW,CAAE,IAAI,CACjBC,YAAY,CAAE,EAChB,CAAC,CAAC,CACFmF,cAAc,CAAC,CAAC,CAChB,OACF,CAEA,GAAIiB,MAAM,GAAK,UAAU,EAAIT,WAAW,GAAK7G,UAAU,CAAE,CACvD,GAAI4G,SAAS,CAACnB,IAAI,GAAKG,MAAM,CAAE,CAC7BE,QAAQ,CAAC9F,UAAU,CAAC,CAACyH,KAAK,EAAI,GAAG,CAEjC;AACA,KAAM,CAAAC,cAAc,CAAG,CAAC,GAAG5B,QAAQ,CAACe,WAAW,CAAC,CAACZ,KAAK,CAAC,CACvDyB,cAAc,CAACT,OAAO,CAAEU,IAAI,EAAK,CAC/B,GAAIA,IAAI,GAAK/B,MAAM,CAAE,CACnB;AACAE,QAAQ,CAACe,WAAW,CAAC,CAACZ,KAAK,CAAGH,QAAQ,CAACe,WAAW,CAAC,CAACZ,KAAK,CAAC5C,MAAM,CAAC8C,CAAC,EAAIA,CAAC,GAAKwB,IAAI,CAAC,CACjF;AACA,GAAI,CAAC7B,QAAQ,CAAC9F,UAAU,CAAC,CAACiG,KAAK,CAACC,QAAQ,CAACyB,IAAI,CAAC,CAAE,CAC9C7B,QAAQ,CAAC9F,UAAU,CAAC,CAACiG,KAAK,CAACpD,IAAI,CAAC8E,IAAI,CAAC,CACvC,CACF,CACF,CAAC,CAAC,CAEF;AACA7B,QAAQ,CAACe,WAAW,CAAC,CAACpB,IAAI,CAAG,IAAI,CAEjC;AACAK,QAAQ,CAACe,WAAW,CAAC,CAACZ,KAAK,CAAGH,QAAQ,CAACe,WAAW,CAAC,CAACZ,KAAK,CAAC5C,MAAM,CAAC8C,CAAC,EAAIA,CAAC,GAAKP,MAAM,CAAC,CACnFE,QAAQ,CAAC9F,UAAU,CAAC,CAACiG,KAAK,CAACpD,IAAI,CAAC+C,MAAM,CAAC,CACvCE,QAAQ,CAAC9F,UAAU,CAAC,CAACyF,IAAI,CAAGG,MAAM,CACpC,CAAC,IAAM,CACLE,QAAQ,CAAC9F,UAAU,CAAC,CAACyH,KAAK,EAAI,GAAG,CACjC;AACA3B,QAAQ,CAACe,WAAW,CAAC,CAACZ,KAAK,CAAGH,QAAQ,CAACe,WAAW,CAAC,CAACZ,KAAK,CAAC5C,MAAM,CAAC8C,CAAC,EAAIA,CAAC,GAAKP,MAAM,CAAC,CACnFE,QAAQ,CAAC9F,UAAU,CAAC,CAACiG,KAAK,CAACpD,IAAI,CAAC+C,MAAM,CAAC,CACzC,CACF,CAAC,IAAM,IAAI0B,MAAM,GAAK,UAAU,CAAE,CAChC;AACAxB,QAAQ,CAACe,WAAW,CAAC,CAACY,KAAK,EAAI,GAAG,CACpC,CAEAnI,QAAQ,CAACwG,QAAQ,CAAC,CAClB3F,qBAAqB,CAAC,IAAI,CAAC,CAC3BE,eAAe,CAAC,CACdC,gBAAgB,CAAE,KAAK,CACvBC,gBAAgB,CAAE,KAAK,CACvBC,eAAe,CAAE,IAAI,CACrBC,eAAe,CAAE,IAAI,CACrBC,cAAc,CAAE,IAAI,CACpBxC,SAAS,CAAE,KAAK,CAChByC,cAAc,CAAE,IAAI,CACpBC,cAAc,CAAE,IAAI,CACpBC,aAAa,CAAE,EAAE,CACjBC,SAAS,CAAE,KAAK,CAChBC,eAAe,CAAE,CAAC,CAClBC,YAAY,CAAE,CAAC,CACfC,WAAW,CAAE,IAAI,CACjBC,YAAY,CAAE,EAChB,CAAC,CAAC,CACFmF,cAAc,CAAC,CAAC,CAClB,CAAC,CACD,CAACrG,UAAU,CAAEqG,cAAc,CAAEhH,KAAK,CAAE8E,YAAY,CAClD,CAAC,CAEDjI,KAAK,CAACwF,SAAS,CAAC,IAAM,CACpB,GACExB,kBAAkB,EAClB,CAACE,YAAY,CAAClC,SAAS,EACvBkC,YAAY,CAACE,gBAAgB,EAC7BF,YAAY,CAACG,gBAAgB,CAC7B,CACA8G,mBAAmB,CAACjH,YAAY,CAAEF,kBAAkB,CAAC,CACvD,CACF,CAAC,CAAE,CAACE,YAAY,CAAEF,kBAAkB,CAAEmH,mBAAmB,CAAC,CAAC,CAE3D,KAAM,CAAAO,oBAAoB,CAAG1L,KAAK,CAACgH,WAAW,CAC3C2E,SAAS,EAAK,CACb,GAAI,CAAC3H,kBAAkB,CAAE,OAEzB;AACAG,eAAe,CAAEmE,IAAI,EAAK,CACxB;AACA,GAAIA,IAAI,CAAC7D,cAAc,GAAKkH,SAAS,CAAE,CACrC,OAAAlD,aAAA,CAAAA,aAAA,IACKH,IAAI,MACP7D,cAAc,CAAE,IAAI,CACpBL,gBAAgB,CAAE,KAAK,CACvBO,aAAa,CAAE2D,IAAI,CAAC3D,aAAa,CAACwC,MAAM,CAACyE,IAAI,EAAIA,IAAI,GAAK,UAAU,CAAC,GAEzE,CAEA,KAAM,CAAAC,gBAAgB,CAAG,CAAC,GAAGvD,IAAI,CAAC3D,aAAa,CAAC,CAChD,GAAI,CAACkH,gBAAgB,CAAC7B,QAAQ,CAAC,UAAU,CAAC,CAAE,CAC1C6B,gBAAgB,CAAClF,IAAI,CAAC,UAAU,CAAC,CACnC,CAEA,KAAM,CAAAmE,IAAI,CAAArC,aAAA,CAAAA,aAAA,IACLH,IAAI,MACP7D,cAAc,CAAEkH,SAAS,CACzBvH,gBAAgB,CAAE,IAAI,CACtBE,eAAe,CAAEqH,SAAS,CAC1BhH,aAAa,CAAEkH,gBAAgB,EAChC,CAED,MAAO,CAAAf,IAAI,CACb,CAAC,CAAC,CACJ,CAAC,CACD,CAAC5G,YAAY,CAAClC,SAAS,CAAEkC,YAAY,CAACO,cAAc,CAAE0F,cAAc,CAAEnG,kBAAkB,CAAEF,UAAU,CAAEX,KAAK,CAAE8E,YAAY,CAC3H,CAAC,CAED,KAAM,CAAA6D,oBAAoB,CAAG9L,KAAK,CAACgH,WAAW,CAC3C2E,SAAS,EAAK,CACb,GAAI,CAAC3H,kBAAkB,CAAE,OAEzBG,eAAe,CAAEmE,IAAI,EAAK,CACxB;AACA,GAAIA,IAAI,CAAC5D,cAAc,GAAKiH,SAAS,CAAE,CACrC,OAAAlD,aAAA,CAAAA,aAAA,IACKH,IAAI,MACP5D,cAAc,CAAE,IAAI,CACpBL,gBAAgB,CAAE,KAAK,CACvBM,aAAa,CAAE2D,IAAI,CAAC3D,aAAa,CAACwC,MAAM,CAACyE,IAAI,EAAIA,IAAI,GAAK,UAAU,CAAC,GAEzE,CAEA,KAAM,CAAAC,gBAAgB,CAAG,CAAC,GAAGvD,IAAI,CAAC3D,aAAa,CAAC,CAChD,GAAI,CAACkH,gBAAgB,CAAC7B,QAAQ,CAAC,UAAU,CAAC,CAAE,CAC1C6B,gBAAgB,CAAClF,IAAI,CAAC,UAAU,CAAC,CACnC,CAEA,KAAM,CAAAmE,IAAI,CAAArC,aAAA,CAAAA,aAAA,IACLH,IAAI,MACP5D,cAAc,CAAEiH,SAAS,CACzBtH,gBAAgB,CAAE,IAAI,CACtBE,eAAe,CAAEoH,SAAS,CAC1BhH,aAAa,CAAEkH,gBAAgB,EAChC,CAED,MAAO,CAAAf,IAAI,CACb,CAAC,CAAC,CACJ,CAAC,CACD,CAAC9G,kBAAkB,CACrB,CAAC,CAED;AACA,KAAM,CAAA+H,iBAAiB,CAAGA,CAACC,MAAM,CAAEC,QAAQ,GAAK,CAC9C,GAAI,CAACA,QAAQ,CAAE,MAAO,EAAE,CACxB,KAAM,CAAAC,KAAK,CAAGhI,YAAY,CAACS,aAAa,CAACwH,OAAO,CAACH,MAAM,CAAC,CACxD,MAAO,CAAAE,KAAK,GAAK,CAAC,CAAC,CAAG,CAACA,KAAK,CAAG,CAAC,EAAEE,QAAQ,CAAC,CAAC,CAAG,EAAE,CACnD,CAAC,CAED,mBACE5L,KAAA,CAACC,aAAa,EAAA4L,QAAA,eACZ7L,KAAA,CAACK,UAAU,EAAAwL,QAAA,eACT/L,IAAA,CAACH,GAAG,EACFgD,KAAK,CAAEA,KAAM,CACbiG,aAAa,CAAEA,aAAc,CAC7B9F,SAAS,CAAEA,SAAU,CACrBgJ,aAAa,CACXhJ,SAAS,GAAK,SAAS,EAAIQ,UAAU,GAAK,IAAI,CAC1CZ,GAAG,CAACqJ,gBAAgB,CACpBpJ,KAAK,CAACgE,MAAM,CAAC,CAACqF,CAAC,CAAEN,KAAK,GAAKA,KAAK,GAAKpI,UAAU,CAAC,CAAC2I,OAAO,CAAEnD,IAAI,EAAKA,IAAI,CAACS,KAAK,CAC/E,CAAC,CACC,EACL,CACDS,WAAW,CAAEA,WAAY,CAC1B,CAAC,cAGFlK,IAAA,CAACiC,UAAU,EACTD,QAAQ,CAAEuF,OAAO,CAACP,MAAM,GAAK,CAAE,CAC/BoF,OAAO,CAAEhE,IAAK,CACdiE,KAAK,CAAC,0JAA6B,CAAAN,QAAA,cAEnC/L,IAAA,QAAKsM,GAAG,CAAC,4BAA4B,CAACC,GAAG,CAAC,kDAAU,CAAE,CAAC,CAC7C,CAAC,cAEbvM,IAAA,CAACmC,UAAU,EACTH,QAAQ,CAAEyF,MAAM,CAACT,MAAM,GAAK,CAAE,CAC9BoF,OAAO,CAAEzD,IAAK,CACd0D,KAAK,CAAC,sKAA+B,CAAAN,QAAA,cAErC/L,IAAA,QAAKsM,GAAG,CAAC,4BAA4B,CAACC,GAAG,CAAC,wDAAW,CAAE,CAAC,CAC9C,CAAC,CAEZ7I,kBAAkB,eACjB1D,IAAA,CAACS,oBAAoB,EAAAsL,QAAA,cACnB7L,KAAA,CAACS,gBAAgB,EAAAoL,QAAA,eAEf7L,KAAA,CAACqB,uBAAuB,EAACiL,SAAS,CAAC,MAAM,CAAC9K,SAAS,CAAE,KAAM,CAAAqK,QAAA,eACzD/L,IAAA,CAAC2B,aAAa,EACZ6K,SAAS,CAAE5I,YAAY,CAACQ,cAAc,GAAK,KAAK,CAAG,QAAQ,CAAG,EAAG,CACjEgI,OAAO,CAAEA,CAAA,GAAMZ,oBAAoB,CAAC,KAAK,CAAE,CAC3C,aAAYC,iBAAiB,CAAC,UAAU,CAAE7H,YAAY,CAACQ,cAAc,GAAK,KAAK,CAAE,CAAA2H,QAAA,cAEjF/L,IAAA,QAAKsM,GAAG,CAAC,oCAAoC,CAACC,GAAG,CAAC,iFAAgB,CAAE,CAAC,CACxD,CAAC,cAChBvM,IAAA,CAAC2B,aAAa,EACZ6K,SAAS,CAAE5I,YAAY,CAACQ,cAAc,GAAK,IAAI,CAAG,QAAQ,CAAG,EAAG,CAChEgI,OAAO,CAAEA,CAAA,GAAMZ,oBAAoB,CAAC,IAAI,CAAE,CAC1C,aAAYC,iBAAiB,CAAC,UAAU,CAAE7H,YAAY,CAACQ,cAAc,GAAK,IAAI,CAAE,CAAA2H,QAAA,cAEhF/L,IAAA,QAAKsM,GAAG,CAAC,sCAAsC,CAACC,GAAG,CAAC,qEAAc,CAAE,CAAC,CACxD,CAAC,EACO,CAAC,cAI1BrM,KAAA,CAACW,mBAAmB,EAAAkL,QAAA,eAClB7L,KAAA,CAACe,iBAAiB,EAAA8K,QAAA,EAAC,uCACV,CAACrI,kBAAkB,CAAC,GAAC,CAACE,YAAY,CAACU,SAAS,iDAAA/B,MAAA,CAAgBqB,YAAY,CAACW,eAAe,MAAAhC,MAAA,CAAIqB,YAAY,CAACY,YAAY,KAAG,EAC9G,CAAC,cACpBxE,IAAA,CAACoB,gBAAgB,EAAA2K,QAAA,CACdnI,YAAY,CAACa,WAAW,CAAGb,YAAY,CAACa,WAAW,CAACgB,IAAI,CACvDd,cAAc,CAACqC,MAAM,CAAG,CAAC,EAAIjC,WAAW,CAAC0H,IAAI,EAAI9H,cAAc,CAACqC,MAAM,CAClE,WAAW,CACVpD,YAAY,CAACU,SAAS,+QAAA/B,MAAA,CACkCqB,YAAY,CAACY,YAAY,4FAChF,qKACP,CACe,CAAC,CAClBZ,YAAY,CAACa,WAAW,EAAIb,YAAY,CAACa,WAAW,CAAC8B,SAAS,eAC7DvG,IAAA,CAACe,4BAA4B,EAAAgL,QAAA,cAC3B/L,IAAA,QAAKsM,GAAG,CAAE1I,YAAY,CAACa,WAAW,CAAC8B,SAAU,CAACgG,GAAG,CAAC,mBAAmB,CAAE,CAAC,CAC5C,CAC/B,EACkB,CAAC,cAGtBrM,KAAA,CAACqB,uBAAuB,EAACiL,SAAS,CAAC,OAAO,CAAC9K,SAAS,CAAE,KAAM,CAAAqK,QAAA,eAC1D/L,IAAA,CAAC2B,aAAa,EACZ6K,SAAS,CAAE5I,YAAY,CAACO,cAAc,GAAK,KAAK,CAAG,QAAQ,CAAG,EAAG,CACjEiI,OAAO,CAAEA,CAAA,GAAMhB,oBAAoB,CAAC,KAAK,CAAE,CAC3C,aAAYK,iBAAiB,CAAC,UAAU,CAAE7H,YAAY,CAACO,cAAc,GAAK,KAAK,CAAE,CAAA4H,QAAA,cAEjF/L,IAAA,QAAKsM,GAAG,CAAC,oCAAoC,CAACC,GAAG,CAAC,2EAAe,CAAE,CAAC,CACvD,CAAC,cAChBvM,IAAA,CAAC2B,aAAa,EACZ6K,SAAS,CAAE5I,YAAY,CAACO,cAAc,GAAK,IAAI,CAAG,QAAQ,CAAG,EAAG,CAChEiI,OAAO,CAAEA,CAAA,GAAMhB,oBAAoB,CAAC,IAAI,CAAE,CAC1C,aAAYK,iBAAiB,CAAC,UAAU,CAAE7H,YAAY,CAACO,cAAc,GAAK,IAAI,CAAE,CAAA4H,QAAA,cAEhF/L,IAAA,QAAKsM,GAAG,CAAC,sCAAsC,CAACC,GAAG,CAAC,+DAAa,CAAE,CAAC,CACvD,CAAC,EACO,CAAC,EACV,CAAC,CACC,CACvB,EACS,CAAC,cAEbvM,IAAA,CAACJ,YAAY,EACXiD,KAAK,CAAEA,KAAM,CACbW,UAAU,CAAEA,UAAW,CACvBE,kBAAkB,CAAEA,kBAAmB,CACvCE,YAAY,CAAEA,YAAa,CAC3B8I,WAAW,CAAGC,QAAQ,EAAK,CACzB,KAAM,CAAAC,KAAK,CAAG/H,eAAe,CAACA,eAAe,CAACmC,MAAM,CAAG,CAAC,CAAC,CACzD,KAAM,CAAA6F,kBAAkB,CAAGhI,eAAe,CAACwC,KAAK,CAAC,CAAC,CAAE,CAAC,CAAC,CAAC,CAEvDM,YAAY,CAAC,CAAC,CACd,KAAM,CAAA2B,QAAQ,CAAG,CACf,GAAGzG,KAAK,CACR,CACEiK,IAAI,CAAEH,QAAQ,CACd1B,KAAK,CAAE,IAAI,CACXxB,KAAK,CAAE,EAAE,CACTmD,KAAK,CAAEA,KAAK,CACZ3D,IAAI,CAAE,IACR,CAAC,CACF,CACDnG,QAAQ,CAACwG,QAAQ,CAAC,CAClBxE,kBAAkB,CAAC+H,kBAAkB,CAAC,CACxC,CAAE,CACFE,WAAW,CAAG1D,SAAS,EAAK,CAC1B,GAAIrG,SAAS,GAAK,SAAS,CAAE,CAC3B2E,YAAY,CAAC,CAAC,CACdlE,aAAa,CAAC4F,SAAS,GAAK7F,UAAU,CAAG,IAAI,CAAG6F,SAAS,CAAC,CAC5D,CACF,CAAE,CACF2D,WAAW,CAAEA,CAAA,GAAM,CACjBrF,YAAY,CAAC,CAAC,CACd1E,YAAY,CAAC,SAAS,CAAC,CACvBI,cAAc,CAAC,CAAC,CAAC,CACjBE,cAAc,CAAC,CAAC,CAAC,CACjBJ,aAAa,CAACN,KAAK,CAACD,GAAG,CAAC,CAACqK,GAAG,CAAErB,KAAK,GAAKA,KAAK,CAAC,CAAC,CAC/CnI,aAAa,CAAC,CAAC,CAAC,CAClB,CAAE,CACFoG,cAAc,CAAEA,CAAA,GAAM,CACpBlC,YAAY,CAAC,CAAC,CACdkC,cAAc,CAAC,CAAC,CAClB,CAAE,CACF7G,SAAS,CAAEA,SAAU,CACrBI,WAAW,CAAEF,UAAU,CAACE,WAAW,CAAE,CACrCE,WAAW,CAAEA,WAAY,CAC1B,CAAC,EACY,CAAC,CAErB,CAAC,CAED,cAAe,CAAAZ,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}