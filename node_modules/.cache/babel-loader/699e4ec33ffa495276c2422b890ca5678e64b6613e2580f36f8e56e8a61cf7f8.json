{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Samen\\\\Documents\\\\GitHub\\\\test\\\\src\\\\components\\\\game.js\",\n  _s = $RefreshSig$();\nimport * as React from 'react';\nimport styled from 'styled-components';\nimport GameControls from './game-controls';\nimport Map from './map';\nimport { shuffleArray } from '../logic/utils';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GameContainer = styled.div`\n  display: flex;\n  gap: 10px;\n  padding: 10px;\n  position: relative;\n  height: calc(100% - 20px);\n`;\n_c = GameContainer;\nconst MapWrapper = styled.div`\n  position: relative;\n  background: #a1cef6;\n  border-radius: 10px;\n  width: 80%;\n  height: 100%;\n`;\n_c2 = MapWrapper;\nconst CaptureModalBackdrop = styled.div`\n  position: absolute;\n  inset: 0;\n  background: transparent;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 1000;\n  pointer-events: none;\n`;\n_c3 = CaptureModalBackdrop;\nconst CaptureModalCard = styled.div`\n  background: #ffffff;\n  border: 4px solid #000;\n  border-radius: 0;\n  padding: 0;\n  width: 95%;\n  max-width: 900px;\n  height: auto;\n  min-height: 400px;\n  max-height: 90%;\n  box-shadow: 0 24px 80px rgba(0, 0, 0, 0.5);\n  display: flex;\n  flex-direction: row;\n  position: relative;\n  overflow: visible;\n  pointer-events: auto;\n`;\n_c4 = CaptureModalCard;\nconst CaptureModalContent = styled.div`\n  flex: 1;\n  padding: 32px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  text-align: center;\n`;\n_c5 = CaptureModalContent;\nconst CaptureModalImagePlaceholder = styled.div`\n  width: 100%;\n  max-width: 500px;\n  height: auto;\n  min-height: 50px;\n  max-height: 400px;\n  border: 2px solid #333;\n  background: #f2f2f2;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: #777;\n  font-size: 14px;\n  margin-top: 15px;\n  overflow: hidden;\n\n  img {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n    max-height: 400px;\n  }\n`;\n_c6 = CaptureModalImagePlaceholder;\nconst CaptureModalTitle = styled.h2`\n  margin: 0 0 12px;\n  font-size: 24px;\n  font-weight: normal;\n  text-transform: uppercase;\n`;\n_c7 = CaptureModalTitle;\nconst CaptureModalText = styled.p`\n  margin: 0 0 15px;\n  font-size: 16px;\n  line-height: 1.4;\n  color: #000;\n  max-width: 700px;\n`;\n_c8 = CaptureModalText;\nconst CaptureModalSideActions = styled.div`\n  width: 100px;\n  display: flex;\n  flex-direction: column;\n  justify-content: ${props => props.isNeutral ? 'space-between' : 'flex-end'};\n  align-items: center;\n  gap: 15px;\n  padding: 15px;\n  \n  &.left {\n    border-right: none;\n  }\n  \n  &.right {\n    border-left: none;\n  }\n`;\n_c9 = CaptureModalSideActions;\nconst CaptureButton = styled.button`\n  position: relative;\n  width: 70px;\n  height: 70px;\n  padding: 0;\n  border-radius: 0;\n  border: none;\n  background: transparent;\n  cursor: pointer;\n  transition: transform 0.1s ease;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  &::after {\n    content: attr(data-order);\n    position: absolute;\n    top: -5px;\n    right: -5px;\n    width: 24px;\n    height: 24px;\n    border-radius: 50%;\n    background: #000;\n    color: #fff;\n    font-size: 14px;\n    font-weight: bold;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: ${props => props['data-order'] ? 1 : 0};\n  }\n\n  &:active {\n    transform: scale(0.95);\n  }\n\n  &.active {\n    filter: drop-shadow(0 0 8px rgba(0,0,0,0.5));\n    transform: scale(1.1);\n  }\n\n  img {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n  }\n`;\n_c0 = CaptureButton;\nconst ActionButton = styled.button`\n  position: absolute;\n  bottom: 20px;\n  width: 60px;\n  height: 60px;\n  border-radius: 8px;\n  border: none;\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: ${props => props.disabled ? '#ccc' : '#16a34a'};\n  opacity: ${props => props.disabled ? 0.5 : 1};\n  transition: all 0.2s ease;\n  \n  &:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n  }\n  \n  img {\n    width: 70%;\n    height: 70%;\n    object-fit: contain;\n  }\n`;\nconst UndoButton = styled(ActionButton)`\n  left: 20px;\n`;\n_c1 = UndoButton;\nconst RedoButton = styled(ActionButton)`\n  right: 20px;\n`;\n_c10 = RedoButton;\nconst shuffleTurnsOrder = arr => arr.concat(arr.splice(0, 1));\nconst initialColors = shuffleArray(['#7975b9', '#007F73', '#FB9AD1', '#FFC470', '#C5FF95', '#4793AF', '#ff7171']);\nconst Game = ({\n  map\n}) => {\n  _s();\n  const [teams, setTeams] = React.useState([]);\n  const [gameState, setGameState] = React.useState('prepare');\n  const [turnsOrder, setTurnsOrder] = React.useState([]);\n  const [currentTurn, setCurrentTurn] = React.useState(null);\n  const [roundNumber, setRoundNumber] = React.useState(0);\n  const [activeTeam, setActiveTeam] = React.useState(null);\n  const [pendingCaptureZone, setPendingCaptureZone] = React.useState(null);\n  const [captureState, setCaptureState] = React.useState({\n    attackerAnswered: false,\n    defenderAnswered: false,\n    attackerCorrect: null,\n    defenderCorrect: null,\n    firstResponder: null,\n    isNeutral: false,\n    attackerAnswer: null,\n    defenderAnswer: null,\n    responseOrder: [],\n    isCapital: false,\n    consecutiveWins: 0,\n    requiredWins: 3,\n    currentTask: null,\n    capitalTasks: []\n  });\n  const [availableTasks, setAvailableTasks] = React.useState([]);\n  const [availableColors, setAvailableColors] = React.useState([...initialColors]);\n  const [usedTaskIds, setUsedTaskIds] = React.useState(new Set());\n\n  // Load available tasks on component mount\n  React.useEffect(() => {\n    const loadTasks = async () => {\n      try {\n        const tasks = [];\n        let taskNumber = 1;\n\n        // Loop to find all available tasks\n        while (taskNumber <= 100) {\n          try {\n            // 1. Fetch the text file\n            const response = await fetch(`/tasks/${taskNumber}.txt`);\n            if (!response.ok) break;\n            const text = await response.text();\n\n            // CRITICAL FIX: Check if server returned HTML (index.html) instead of text\n            if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {\n              break; // Stop if we hit the fallback HTML\n            }\n\n            // 2. Check if image exists\n            let hasImage = false;\n            try {\n              const imgResponse = await fetch(`/test/tasks/pics/${taskNumber}.png`, {\n                method: 'HEAD'\n              });\n              if (imgResponse.ok) {\n                const contentType = imgResponse.headers.get('content-type');\n                // Only accept if it's actually an image or if we can't check content-type but response was OK\n                if (!contentType || contentType.startsWith('image/')) {\n                  hasImage = true;\n                }\n              }\n            } catch (e) {\n              console.warn('Failed to check image', e);\n            }\n            tasks.push({\n              id: taskNumber,\n              text: text.trim(),\n              imagePath: hasImage ? `/test/tasks/pics/${taskNumber}.png` : null\n            });\n            taskNumber++;\n          } catch (error) {\n            break;\n          }\n        }\n        setAvailableTasks(tasks);\n      } catch (error) {\n        console.error('Error loading tasks:', error);\n      }\n    };\n    loadTasks();\n  }, []);\n\n  // Helper function to select random tasks\n  const selectRandomTasks = React.useCallback(count => {\n    // Filter out used tasks\n    const unusedTasks = availableTasks.filter(task => !usedTaskIds.has(task.id));\n    if (unusedTasks.length === 0) return [];\n    const shuffled = [...unusedTasks].sort(() => Math.random() - 0.5);\n    return shuffled.slice(0, Math.min(count, unusedTasks.length));\n  }, [availableTasks, usedTaskIds]);\n\n  // History state\n  const [history, setHistory] = React.useState([]);\n  const [future, setFuture] = React.useState([]);\n  const recordAction = React.useCallback(() => {\n    const currentState = {\n      teams: JSON.parse(JSON.stringify(teams)),\n      gameState,\n      turnsOrder: [...turnsOrder],\n      currentTurn,\n      roundNumber,\n      activeTeam,\n      availableColors: [...availableColors],\n      usedTaskIds: new Set(usedTaskIds),\n      pendingCaptureZone,\n      captureState: JSON.parse(JSON.stringify(captureState))\n    };\n    setHistory(prev => [...prev, currentState]);\n    setFuture([]);\n  }, [teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors, usedTaskIds, pendingCaptureZone, captureState]);\n  const restoreState = React.useCallback(state => {\n    setTeams(state.teams);\n    setGameState(state.gameState);\n    setTurnsOrder(state.turnsOrder);\n    setCurrentTurn(state.currentTurn);\n    setRoundNumber(state.roundNumber);\n    setActiveTeam(state.activeTeam);\n    setAvailableColors(state.availableColors);\n    setUsedTaskIds(state.usedTaskIds || new Set());\n\n    // Restore UI states\n    setPendingCaptureZone(state.pendingCaptureZone || null);\n\n    // If we're restoring a capture state, reset the answered states\n    // to prevent auto-resolution while keeping task information\n    if (state.captureState) {\n      setCaptureState({\n        ...state.captureState,\n        attackerAnswered: false,\n        defenderAnswered: false,\n        attackerCorrect: null,\n        defenderCorrect: null,\n        attackerAnswer: null,\n        defenderAnswer: null,\n        responseOrder: []\n      });\n    } else {\n      setCaptureState({\n        attackerAnswered: false,\n        defenderAnswered: false,\n        attackerCorrect: null,\n        defenderCorrect: null,\n        firstResponder: null,\n        isNeutral: false,\n        attackerAnswer: null,\n        defenderAnswer: null,\n        responseOrder: [],\n        isCapital: false,\n        consecutiveWins: 0,\n        requiredWins: 3,\n        currentTask: null,\n        capitalTasks: []\n      });\n    }\n  }, []);\n  const undo = React.useCallback(() => {\n    // If capture window is open\n    if (pendingCaptureZone !== null) {\n      // Special handling for capital attacks with multiple stages\n      if (captureState.isCapital && captureState.consecutiveWins > 0) {\n        // Revert to previous stage instead of closing\n        const previousWins = captureState.consecutiveWins - 1;\n        const previousTask = captureState.capitalTasks[previousWins] || captureState.capitalTasks[0];\n        setCaptureState({\n          ...captureState,\n          consecutiveWins: previousWins,\n          currentTask: previousTask,\n          attackerAnswered: false,\n          defenderAnswered: false,\n          attackerCorrect: null,\n          defenderCorrect: null,\n          attackerAnswer: null,\n          defenderAnswer: null,\n          responseOrder: []\n        });\n        return;\n      }\n\n      // For regular attacks or first stage of capital attack, close the window\n      // Save the current state (with window open) to future before closing\n      const stateWithWindowOpen = {\n        teams: JSON.parse(JSON.stringify(teams)),\n        gameState,\n        turnsOrder: [...turnsOrder],\n        currentTurn,\n        roundNumber,\n        activeTeam,\n        availableColors: [...availableColors],\n        usedTaskIds: new Set(usedTaskIds),\n        pendingCaptureZone,\n        captureState: JSON.parse(JSON.stringify(captureState))\n      };\n      setFuture(prev => [stateWithWindowOpen, ...prev]);\n      setPendingCaptureZone(null);\n      setCaptureState({\n        attackerAnswered: false,\n        defenderAnswered: false,\n        attackerCorrect: null,\n        defenderCorrect: null,\n        firstResponder: null,\n        isNeutral: false,\n        attackerAnswer: null,\n        defenderAnswer: null,\n        responseOrder: [],\n        isCapital: false,\n        consecutiveWins: 0,\n        requiredWins: 3,\n        currentTask: null,\n        capitalTasks: []\n      });\n\n      // Also revert the used tasks that were marked when opening this window\n      // by restoring from the last history state\n      if (history.length > 0) {\n        const lastState = history[history.length - 1];\n        if (lastState.usedTaskIds) {\n          setUsedTaskIds(lastState.usedTaskIds);\n        }\n      }\n      return;\n    }\n    if (history.length === 0) return;\n    const previousState = history[history.length - 1];\n    const newHistory = history.slice(0, -1);\n    const currentState = {\n      teams: JSON.parse(JSON.stringify(teams)),\n      gameState,\n      turnsOrder: [...turnsOrder],\n      currentTurn,\n      roundNumber,\n      activeTeam,\n      availableColors: [...availableColors],\n      usedTaskIds: new Set(usedTaskIds),\n      pendingCaptureZone,\n      captureState: JSON.parse(JSON.stringify(captureState))\n    };\n    setFuture(prev => [currentState, ...prev]);\n    setHistory(newHistory);\n    restoreState(previousState);\n  }, [history, teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors, usedTaskIds, pendingCaptureZone, captureState, restoreState]);\n  const redo = React.useCallback(() => {\n    if (future.length === 0) return;\n    const nextState = future[0];\n    const newFuture = future.slice(1);\n\n    // Save current state to history before restoring\n    const currentState = {\n      teams: JSON.parse(JSON.stringify(teams)),\n      gameState,\n      turnsOrder: [...turnsOrder],\n      currentTurn,\n      roundNumber,\n      activeTeam,\n      availableColors: [...availableColors],\n      usedTaskIds: new Set(usedTaskIds),\n      pendingCaptureZone,\n      captureState: JSON.parse(JSON.stringify(captureState))\n    };\n    setHistory(prev => [...prev, currentState]);\n    setFuture(newFuture);\n    restoreState(nextState);\n  }, [future, teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors, usedTaskIds, pendingCaptureZone, captureState, restoreState]);\n\n  // Получаем basePositions из teams\n  const basePositions = React.useMemo(() => {\n    return teams.map(team => team.base).filter(Boolean);\n  }, [teams]);\n  const setBase = React.useCallback((zoneId, teamIndex) => {\n    const newTeams = [...teams];\n    newTeams[teamIndex].base = zoneId;\n    setTeams(newTeams);\n  }, [teams]);\n  const toggleZoneToTeam = React.useCallback((zoneId, teamIndex) => {\n    const newTeams = [...teams];\n\n    // Проверяем, есть ли уже эта территория у команды\n    const currentTeamHasZone = newTeams[teamIndex].zones.includes(zoneId);\n    if (currentTeamHasZone) {\n      // Убираем территорию у команды\n      newTeams[teamIndex].zones = newTeams[teamIndex].zones.filter(z => z !== zoneId);\n\n      // Если это была столица, убираем и столицу\n      if (newTeams[teamIndex].base === zoneId) {\n        newTeams[teamIndex].base = null;\n      }\n    } else {\n      // Убираем территорию у предыдущего владельца\n      for (let i = 0; i < newTeams.length; i++) {\n        if (newTeams[i].zones.includes(zoneId)) {\n          newTeams[i].zones = newTeams[i].zones.filter(z => z !== zoneId);\n\n          // Если у предыдущего владельца это была столица, убираем столицу\n          if (newTeams[i].base === zoneId) {\n            newTeams[i].base = null;\n          }\n          break;\n        }\n      }\n\n      // Добавляем территорию новой команде\n      newTeams[teamIndex].zones.push(zoneId);\n\n      // Если это первая территория в режиме подготовки, устанавливаем столицу\n      if (gameState === 'prepare' && !newTeams[teamIndex].base) {\n        newTeams[teamIndex].base = zoneId;\n      }\n    }\n    setTeams(newTeams);\n  }, [teams, gameState]);\n  const onTurnComplete = React.useCallback(() => {\n    const nextTeam = turnsOrder.slice(currentTurn + 1).find(teamIndex => teams[teamIndex].zones.length > 0);\n    if (typeof nextTeam !== 'undefined') {\n      setCurrentTurn(currentTurn + 1);\n      setActiveTeam(nextTeam);\n      return;\n    }\n    setRoundNumber(roundNumber + 1);\n    setCurrentTurn(0);\n    const newTurnsOrder = shuffleTurnsOrder([...turnsOrder].map(teamIndex => teams[teamIndex].zones.length > 0 ? teamIndex : undefined).filter(i => typeof i !== 'undefined'));\n    setTurnsOrder(newTurnsOrder);\n    setActiveTeam(newTurnsOrder[0]);\n  }, [currentTurn, roundNumber, teams, turnsOrder]);\n  const onZoneClick = React.useCallback((zoneId, isRightClick) => {\n    if (gameState === 'prepare' && activeTeam !== null) {\n      recordAction();\n      toggleZoneToTeam(zoneId, activeTeam);\n    }\n    if (gameState === 'started') {\n      // Ignore right-click\n      if (isRightClick) return;\n      const zoneOwner = teams.find(team => team.zones.includes(zoneId));\n      const zoneOwnerId = teams.findIndex(team => team.zones.includes(zoneId));\n\n      // neutral tile: ignore\n      if (!zoneOwner) {\n        return;\n      }\n\n      // own tile: ignore\n      if (zoneOwnerId === activeTeam) {\n        return;\n      }\n\n      // enemy tile: open confirmation window\n      const isCapital = zoneOwner.base === zoneId;\n\n      // Select tasks for this attack\n      let selectedTasks = [];\n      let currentTask = null;\n      if (isCapital) {\n        // For capital, select 3 different tasks\n        selectedTasks = selectRandomTasks(3);\n        currentTask = selectedTasks[0] || null;\n      } else {\n        // For regular territory, select 1 task\n        selectedTasks = selectRandomTasks(1);\n        currentTask = selectedTasks[0] || null;\n      }\n\n      // Mark tasks as used\n      if (selectedTasks.length > 0) {\n        setUsedTaskIds(prev => {\n          const next = new Set(prev);\n          selectedTasks.forEach(t => next.add(t.id));\n          return next;\n        });\n      }\n\n      // Clear future/redo stack when starting a new attack\n      setFuture([]);\n      setPendingCaptureZone(zoneId);\n      setCaptureState({\n        attackerAnswered: false,\n        defenderAnswered: false,\n        attackerCorrect: null,\n        defenderCorrect: null,\n        firstResponder: null,\n        isNeutral: false,\n        attackerAnswer: null,\n        defenderAnswer: null,\n        responseOrder: [],\n        isCapital: isCapital,\n        consecutiveWins: 0,\n        requiredWins: 3,\n        currentTask: currentTask,\n        capitalTasks: selectedTasks\n      });\n    }\n  }, [activeTeam, gameState, onTurnComplete, teams, toggleZoneToTeam, recordAction, selectRandomTasks]);\n  const cancelCapture = React.useCallback(() => {\n    setPendingCaptureZone(null);\n    setCaptureState({\n      attackerAnswered: false,\n      defenderAnswered: false,\n      attackerCorrect: null,\n      defenderCorrect: null,\n      firstResponder: null,\n      isNeutral: false,\n      attackerAnswer: null,\n      defenderAnswer: null,\n      responseOrder: []\n    });\n  }, []);\n  const maybeResolveCapture = React.useCallback((state, zoneId) => {\n    if (!state.attackerAnswered || !state.defenderAnswered) return;\n    const zoneOwner = teams.find(team => team.zones.includes(zoneId));\n    const zoneOwnerId = teams.findIndex(team => team.zones.includes(zoneId));\n    if (!zoneOwner || zoneOwnerId === -1) {\n      return;\n    }\n    recordAction();\n    let winner = 'defender';\n    if (!state.attackerCorrect && !state.defenderCorrect) {\n      winner = 'defender';\n    } else if (state.attackerCorrect && !state.defenderCorrect) {\n      winner = 'attacker';\n    } else if (!state.attackerCorrect && state.defenderCorrect) {\n      winner = 'defender';\n    } else if (state.attackerCorrect && state.defenderCorrect) {\n      winner = state.responseOrder[0] === 'attacker' ? 'attacker' : 'defender';\n    }\n    const newTeams = [...teams];\n\n    // Handle capital attack - need 3 consecutive wins\n    if (state.isCapital && winner === 'attacker') {\n      const newConsecutiveWins = state.consecutiveWins + 1;\n      if (newConsecutiveWins < state.requiredWins) {\n        // Not enough wins yet, reset the modal for next encounter\n        // Use the next task for capital attacks\n        const nextTask = state.capitalTasks[newConsecutiveWins] || state.currentTask;\n        setCaptureState({\n          attackerAnswered: false,\n          defenderAnswered: false,\n          attackerCorrect: null,\n          defenderCorrect: null,\n          firstResponder: null,\n          isNeutral: false,\n          attackerAnswer: null,\n          defenderAnswer: null,\n          responseOrder: [],\n          isCapital: true,\n          consecutiveWins: newConsecutiveWins,\n          requiredWins: state.requiredWins,\n          currentTask: nextTask,\n          capitalTasks: state.capitalTasks\n        });\n        return; // Keep modal open for next encounter\n      }\n      // If we reach here, attacker has won 3 times - continue to capture\n    } else if (state.isCapital && winner === 'defender') {\n      // Defender won, capital defense successful - close modal and end turn\n      // Award 100 points to defender for successful defense\n      newTeams[zoneOwnerId].score += 100;\n      setTeams(newTeams);\n      setPendingCaptureZone(null);\n      setCaptureState({\n        attackerAnswered: false,\n        defenderAnswered: false,\n        attackerCorrect: null,\n        defenderCorrect: null,\n        firstResponder: null,\n        isNeutral: false,\n        attackerAnswer: null,\n        defenderAnswer: null,\n        responseOrder: [],\n        isCapital: false,\n        consecutiveWins: 0,\n        requiredWins: 3,\n        currentTask: null,\n        capitalTasks: []\n      });\n      onTurnComplete();\n      return;\n    }\n    if (winner === 'attacker' && zoneOwnerId !== activeTeam) {\n      if (zoneOwner.base === zoneId) {\n        newTeams[activeTeam].score += 400;\n\n        // Capture all zones of the defeated team\n        const zonesToCapture = [...newTeams[zoneOwnerId].zones];\n        zonesToCapture.forEach(zone => {\n          if (zone !== zoneId) {\n            // Remove from defeated team\n            newTeams[zoneOwnerId].zones = newTeams[zoneOwnerId].zones.filter(z => z !== zone);\n            // Add to attacker team\n            if (!newTeams[activeTeam].zones.includes(zone)) {\n              newTeams[activeTeam].zones.push(zone);\n            }\n          }\n        });\n\n        // Remove base from defeated team\n        newTeams[zoneOwnerId].base = null;\n\n        // Capture the base zone\n        newTeams[zoneOwnerId].zones = newTeams[zoneOwnerId].zones.filter(z => z !== zoneId);\n        newTeams[activeTeam].zones.push(zoneId);\n        newTeams[activeTeam].base = zoneId;\n      } else {\n        newTeams[activeTeam].score += 100;\n        // Remove from defender and add to attacker\n        newTeams[zoneOwnerId].zones = newTeams[zoneOwnerId].zones.filter(z => z !== zoneId);\n        newTeams[activeTeam].zones.push(zoneId);\n      }\n    } else if (winner === 'defender') {\n      // Defender successfully defended - award 100 points\n      newTeams[zoneOwnerId].score += 100;\n    }\n    setTeams(newTeams);\n    setPendingCaptureZone(null);\n    setCaptureState({\n      attackerAnswered: false,\n      defenderAnswered: false,\n      attackerCorrect: null,\n      defenderCorrect: null,\n      firstResponder: null,\n      isNeutral: false,\n      attackerAnswer: null,\n      defenderAnswer: null,\n      responseOrder: [],\n      isCapital: false,\n      consecutiveWins: 0,\n      requiredWins: 3,\n      currentTask: null,\n      capitalTasks: []\n    });\n    onTurnComplete();\n  }, [activeTeam, onTurnComplete, teams, recordAction]);\n  React.useEffect(() => {\n    if (pendingCaptureZone && !captureState.isNeutral && captureState.attackerAnswered && captureState.defenderAnswered) {\n      maybeResolveCapture(captureState, pendingCaptureZone);\n    }\n  }, [captureState, pendingCaptureZone, maybeResolveCapture]);\n  const handleAttackerAnswer = React.useCallback(isCorrect => {\n    if (!pendingCaptureZone) return;\n\n    // Для вражеских территорий - переключаем выбор\n    setCaptureState(prev => {\n      // Если уже выбран этот вариант - отменяем выбор\n      if (prev.attackerAnswer === isCorrect) {\n        return {\n          ...prev,\n          attackerAnswer: null,\n          attackerAnswered: false,\n          responseOrder: prev.responseOrder.filter(item => item !== 'attacker')\n        };\n      }\n      const newResponseOrder = [...prev.responseOrder];\n      if (!newResponseOrder.includes('attacker')) {\n        newResponseOrder.push('attacker');\n      }\n      const next = {\n        ...prev,\n        attackerAnswer: isCorrect,\n        attackerAnswered: true,\n        attackerCorrect: isCorrect,\n        responseOrder: newResponseOrder\n      };\n      return next;\n    });\n  }, [captureState.isNeutral, captureState.attackerAnswer, onTurnComplete, pendingCaptureZone, activeTeam, teams, recordAction]);\n  const handleDefenderAnswer = React.useCallback(isCorrect => {\n    if (!pendingCaptureZone) return;\n    setCaptureState(prev => {\n      // Если уже выбран этот вариант - отменяем выбор\n      if (prev.defenderAnswer === isCorrect) {\n        return {\n          ...prev,\n          defenderAnswer: null,\n          defenderAnswered: false,\n          responseOrder: prev.responseOrder.filter(item => item !== 'defender')\n        };\n      }\n      const newResponseOrder = [...prev.responseOrder];\n      if (!newResponseOrder.includes('defender')) {\n        newResponseOrder.push('defender');\n      }\n      const next = {\n        ...prev,\n        defenderAnswer: isCorrect,\n        defenderAnswered: true,\n        defenderCorrect: isCorrect,\n        responseOrder: newResponseOrder\n      };\n      return next;\n    });\n  }, [pendingCaptureZone]);\n\n  // Определяем порядок для отображения - теперь функция будет возвращать порядок только для активной кнопки\n  const getOrderForPlayer = (player, isActive) => {\n    if (!isActive) return '';\n    const index = captureState.responseOrder.indexOf(player);\n    return index !== -1 ? (index + 1).toString() : '';\n  };\n  return /*#__PURE__*/_jsxDEV(GameContainer, {\n    children: [/*#__PURE__*/_jsxDEV(MapWrapper, {\n      children: [/*#__PURE__*/_jsxDEV(Map, {\n        teams: teams,\n        basePositions: basePositions,\n        gameState: gameState,\n        disabledZones: gameState === 'prepare' && activeTeam !== null ? map.getAdjucentZones(teams.filter((_, index) => index !== activeTeam).flatMap(team => team.zones)) : [],\n        onZoneClick: onZoneClick\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 895,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(UndoButton, {\n        disabled: history.length === 0,\n        onClick: undo,\n        title: \"\\u041E\\u0442\\u043C\\u0435\\u043D\\u0438\\u0442\\u044C \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u0435\\u0435 \\u0434\\u0435\\u0439\\u0441\\u0442\\u0432\\u0438\\u0435\",\n        children: /*#__PURE__*/_jsxDEV(\"img\", {\n          src: \"/test/images/undo-icon.png\",\n          alt: \"\\u041E\\u0442\\u043C\\u0435\\u043D\\u0438\\u0442\\u044C\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 915,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 910,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(RedoButton, {\n        disabled: future.length === 0,\n        onClick: redo,\n        title: \"\\u041F\\u043E\\u0432\\u0442\\u043E\\u0440\\u0438\\u0442\\u044C \\u043E\\u0442\\u043C\\u0435\\u043D\\u0435\\u043D\\u043D\\u043E\\u0435 \\u0434\\u0435\\u0439\\u0441\\u0442\\u0432\\u0438\\u0435\",\n        children: /*#__PURE__*/_jsxDEV(\"img\", {\n          src: \"/test/images/redo-icon.png\",\n          alt: \"\\u041F\\u043E\\u0432\\u0442\\u043E\\u0440\\u0438\\u0442\\u044C\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 923,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 918,\n        columnNumber: 9\n      }, this), pendingCaptureZone && /*#__PURE__*/_jsxDEV(CaptureModalBackdrop, {\n        children: /*#__PURE__*/_jsxDEV(CaptureModalCard, {\n          children: [/*#__PURE__*/_jsxDEV(CaptureModalSideActions, {\n            className: \"left\",\n            isNeutral: false,\n            children: [/*#__PURE__*/_jsxDEV(CaptureButton, {\n              className: captureState.defenderAnswer === false ? 'active' : '',\n              onClick: () => handleDefenderAnswer(false),\n              \"data-order\": getOrderForPlayer('defender', captureState.defenderAnswer === false),\n              children: /*#__PURE__*/_jsxDEV(\"img\", {\n                src: \"/test/images/defend-wrong-icon.png\",\n                alt: \"\\u0417\\u0430\\u0449\\u0438\\u0442\\u0430 \\u043D\\u0435\\u0432\\u0435\\u0440\\u043D\\u043E\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 936,\n                columnNumber: 19\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 931,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(CaptureButton, {\n              className: captureState.defenderAnswer === true ? 'active' : '',\n              onClick: () => handleDefenderAnswer(true),\n              \"data-order\": getOrderForPlayer('defender', captureState.defenderAnswer === true),\n              children: /*#__PURE__*/_jsxDEV(\"img\", {\n                src: \"/test/images/defend-correct-icon.png\",\n                alt: \"\\u0417\\u0430\\u0449\\u0438\\u0442\\u0430 \\u0432\\u0435\\u0440\\u043D\\u043E\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 943,\n                columnNumber: 19\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 938,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 930,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(CaptureModalContent, {\n            children: [/*#__PURE__*/_jsxDEV(CaptureModalTitle, {\n              children: [\"\\u0420\\u0415\\u0413\\u0418\\u041E\\u041D \", pendingCaptureZone, \" \", captureState.isCapital && `(СТОЛИЦА ${captureState.consecutiveWins}/${captureState.requiredWins})`]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 950,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(CaptureModalText, {\n              children: captureState.currentTask ? captureState.currentTask.text : availableTasks.length > 0 && usedTaskIds.size >= availableTasks.length ? 'Задач нет' : captureState.isCapital ? `Атака на столицу! Для захвата необходимо победить в ${captureState.requiredWins} схватках подряд.` : 'Захват вражеской территории. Здесь будет описание задания или подсказка для игрока. После выполнения задания выберите результат атаки для атакующих и защищающихся.'\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 953,\n              columnNumber: 17\n            }, this), captureState.currentTask && captureState.currentTask.imagePath && /*#__PURE__*/_jsxDEV(CaptureModalImagePlaceholder, {\n              children: /*#__PURE__*/_jsxDEV(\"img\", {\n                src: captureState.currentTask.imagePath,\n                alt: \"Task illustration\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 964,\n                columnNumber: 21\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 963,\n              columnNumber: 19\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 949,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(CaptureModalSideActions, {\n            className: \"right\",\n            isNeutral: false,\n            children: [/*#__PURE__*/_jsxDEV(CaptureButton, {\n              className: captureState.attackerAnswer === false ? 'active' : '',\n              onClick: () => handleAttackerAnswer(false),\n              \"data-order\": getOrderForPlayer('attacker', captureState.attackerAnswer === false),\n              children: /*#__PURE__*/_jsxDEV(\"img\", {\n                src: \"/test/images/attack-wrong-icon.png\",\n                alt: \"\\u0410\\u0442\\u0430\\u043A\\u0430 \\u043D\\u0435\\u0432\\u0435\\u0440\\u043D\\u043E\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 976,\n                columnNumber: 19\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 971,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(CaptureButton, {\n              className: captureState.attackerAnswer === true ? 'active' : '',\n              onClick: () => handleAttackerAnswer(true),\n              \"data-order\": getOrderForPlayer('attacker', captureState.attackerAnswer === true),\n              children: /*#__PURE__*/_jsxDEV(\"img\", {\n                src: \"/test/images/attack-correct-icon.png\",\n                alt: \"\\u0410\\u0442\\u0430\\u043A\\u0430 \\u0432\\u0435\\u0440\\u043D\\u043E\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 983,\n                columnNumber: 19\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 978,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 970,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 928,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 927,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 894,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(GameControls, {\n      teams: teams,\n      activeTeam: activeTeam,\n      pendingCaptureZone: pendingCaptureZone,\n      captureState: captureState,\n      onTeamAdded: teamName => {\n        const color = availableColors[availableColors.length - 1];\n        const newAvailableColors = availableColors.slice(0, -1);\n        recordAction();\n        const newTeams = [...teams, {\n          name: teamName,\n          score: 1000,\n          zones: [],\n          color: color,\n          base: null\n        }];\n        setTeams(newTeams);\n        setAvailableColors(newAvailableColors);\n      },\n      onTeamClick: teamIndex => {\n        if (gameState === 'prepare') {\n          recordAction();\n          setActiveTeam(teamIndex === activeTeam ? null : teamIndex);\n        }\n      },\n      onGameStart: () => {\n        recordAction();\n        setGameState('started');\n        setCurrentTurn(0);\n        setRoundNumber(1);\n        setTurnsOrder(teams.map((tmp, index) => index));\n        setActiveTeam(0);\n      },\n      onTurnComplete: () => {\n        recordAction();\n        onTurnComplete();\n      },\n      gameState: gameState,\n      currentTurn: turnsOrder[currentTurn],\n      roundNumber: roundNumber\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 991,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 893,\n    columnNumber: 5\n  }, this);\n};\n_s(Game, \"0Q16BEe3Jt+Ddr3MjYqdJDAoA88=\");\n_c11 = Game;\nexport default Game;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c0, _c1, _c10, _c11;\n$RefreshReg$(_c, \"GameContainer\");\n$RefreshReg$(_c2, \"MapWrapper\");\n$RefreshReg$(_c3, \"CaptureModalBackdrop\");\n$RefreshReg$(_c4, \"CaptureModalCard\");\n$RefreshReg$(_c5, \"CaptureModalContent\");\n$RefreshReg$(_c6, \"CaptureModalImagePlaceholder\");\n$RefreshReg$(_c7, \"CaptureModalTitle\");\n$RefreshReg$(_c8, \"CaptureModalText\");\n$RefreshReg$(_c9, \"CaptureModalSideActions\");\n$RefreshReg$(_c0, \"CaptureButton\");\n$RefreshReg$(_c1, \"UndoButton\");\n$RefreshReg$(_c10, \"RedoButton\");\n$RefreshReg$(_c11, \"Game\");","map":{"version":3,"names":["React","styled","GameControls","Map","shuffleArray","jsxDEV","_jsxDEV","GameContainer","div","_c","MapWrapper","_c2","CaptureModalBackdrop","_c3","CaptureModalCard","_c4","CaptureModalContent","_c5","CaptureModalImagePlaceholder","_c6","CaptureModalTitle","h2","_c7","CaptureModalText","p","_c8","CaptureModalSideActions","props","isNeutral","_c9","CaptureButton","button","_c0","ActionButton","disabled","UndoButton","_c1","RedoButton","_c10","shuffleTurnsOrder","arr","concat","splice","initialColors","Game","map","_s","teams","setTeams","useState","gameState","setGameState","turnsOrder","setTurnsOrder","currentTurn","setCurrentTurn","roundNumber","setRoundNumber","activeTeam","setActiveTeam","pendingCaptureZone","setPendingCaptureZone","captureState","setCaptureState","attackerAnswered","defenderAnswered","attackerCorrect","defenderCorrect","firstResponder","attackerAnswer","defenderAnswer","responseOrder","isCapital","consecutiveWins","requiredWins","currentTask","capitalTasks","availableTasks","setAvailableTasks","availableColors","setAvailableColors","usedTaskIds","setUsedTaskIds","Set","useEffect","loadTasks","tasks","taskNumber","response","fetch","ok","text","trim","startsWith","hasImage","imgResponse","method","contentType","headers","get","e","console","warn","push","id","imagePath","error","selectRandomTasks","useCallback","count","unusedTasks","filter","task","has","length","shuffled","sort","Math","random","slice","min","history","setHistory","future","setFuture","recordAction","currentState","JSON","parse","stringify","prev","restoreState","state","undo","previousWins","previousTask","stateWithWindowOpen","lastState","previousState","newHistory","redo","nextState","newFuture","basePositions","useMemo","team","base","Boolean","setBase","zoneId","teamIndex","newTeams","toggleZoneToTeam","currentTeamHasZone","zones","includes","z","i","onTurnComplete","nextTeam","find","newTurnsOrder","undefined","onZoneClick","isRightClick","zoneOwner","zoneOwnerId","findIndex","selectedTasks","next","forEach","t","add","cancelCapture","maybeResolveCapture","winner","newConsecutiveWins","nextTask","score","zonesToCapture","zone","handleAttackerAnswer","isCorrect","item","newResponseOrder","handleDefenderAnswer","getOrderForPlayer","player","isActive","index","indexOf","toString","children","disabledZones","getAdjucentZones","_","flatMap","fileName","_jsxFileName","lineNumber","columnNumber","onClick","title","src","alt","className","size","onTeamAdded","teamName","color","newAvailableColors","name","onTeamClick","onGameStart","tmp","_c11","$RefreshReg$"],"sources":["C:/Users/Samen/Documents/GitHub/test/src/components/game.js"],"sourcesContent":["import * as React from 'react';\r\nimport styled from 'styled-components';\r\nimport GameControls from './game-controls';\r\nimport Map from './map';\r\nimport { shuffleArray } from '../logic/utils';\r\n\r\nconst GameContainer = styled.div`\r\n  display: flex;\r\n  gap: 10px;\r\n  padding: 10px;\r\n  position: relative;\r\n  height: calc(100% - 20px);\r\n`;\r\n\r\nconst MapWrapper = styled.div`\r\n  position: relative;\r\n  background: #a1cef6;\r\n  border-radius: 10px;\r\n  width: 80%;\r\n  height: 100%;\r\n`;\r\n\r\nconst CaptureModalBackdrop = styled.div`\r\n  position: absolute;\r\n  inset: 0;\r\n  background: transparent;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 1000;\r\n  pointer-events: none;\r\n`;\r\n\r\nconst CaptureModalCard = styled.div`\r\n  background: #ffffff;\r\n  border: 4px solid #000;\r\n  border-radius: 0;\r\n  padding: 0;\r\n  width: 95%;\r\n  max-width: 900px;\r\n  height: auto;\r\n  min-height: 400px;\r\n  max-height: 90%;\r\n  box-shadow: 0 24px 80px rgba(0, 0, 0, 0.5);\r\n  display: flex;\r\n  flex-direction: row;\r\n  position: relative;\r\n  overflow: visible;\r\n  pointer-events: auto;\r\n`;\r\n\r\nconst CaptureModalContent = styled.div`\r\n  flex: 1;\r\n  padding: 32px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  text-align: center;\r\n`;\r\n\r\nconst CaptureModalImagePlaceholder = styled.div`\r\n  width: 100%;\r\n  max-width: 500px;\r\n  height: auto;\r\n  min-height: 50px;\r\n  max-height: 400px;\r\n  border: 2px solid #333;\r\n  background: #f2f2f2;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  color: #777;\r\n  font-size: 14px;\r\n  margin-top: 15px;\r\n  overflow: hidden;\r\n\r\n  img {\r\n    width: 100%;\r\n    height: 100%;\r\n    object-fit: contain;\r\n    max-height: 400px;\r\n  }\r\n`;\r\n\r\nconst CaptureModalTitle = styled.h2`\r\n  margin: 0 0 12px;\r\n  font-size: 24px;\r\n  font-weight: normal;\r\n  text-transform: uppercase;\r\n`;\r\n\r\nconst CaptureModalText = styled.p`\r\n  margin: 0 0 15px;\r\n  font-size: 16px;\r\n  line-height: 1.4;\r\n  color: #000;\r\n  max-width: 700px;\r\n`;\r\n\r\nconst CaptureModalSideActions = styled.div`\r\n  width: 100px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: ${props => props.isNeutral ? 'space-between' : 'flex-end'};\r\n  align-items: center;\r\n  gap: 15px;\r\n  padding: 15px;\r\n  \r\n  &.left {\r\n    border-right: none;\r\n  }\r\n  \r\n  &.right {\r\n    border-left: none;\r\n  }\r\n`;\r\n\r\nconst CaptureButton = styled.button`\r\n  position: relative;\r\n  width: 70px;\r\n  height: 70px;\r\n  padding: 0;\r\n  border-radius: 0;\r\n  border: none;\r\n  background: transparent;\r\n  cursor: pointer;\r\n  transition: transform 0.1s ease;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n\r\n  &::after {\r\n    content: attr(data-order);\r\n    position: absolute;\r\n    top: -5px;\r\n    right: -5px;\r\n    width: 24px;\r\n    height: 24px;\r\n    border-radius: 50%;\r\n    background: #000;\r\n    color: #fff;\r\n    font-size: 14px;\r\n    font-weight: bold;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    opacity: ${props => props['data-order'] ? 1 : 0};\r\n  }\r\n\r\n  &:active {\r\n    transform: scale(0.95);\r\n  }\r\n\r\n  &.active {\r\n    filter: drop-shadow(0 0 8px rgba(0,0,0,0.5));\r\n    transform: scale(1.1);\r\n  }\r\n\r\n  img {\r\n    width: 100%;\r\n    height: 100%;\r\n    object-fit: contain;\r\n  }\r\n`;\r\n\r\nconst ActionButton = styled.button`\r\n  position: absolute;\r\n  bottom: 20px;\r\n  width: 60px;\r\n  height: 60px;\r\n  border-radius: 8px;\r\n  border: none;\r\n  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background: ${props => props.disabled ? '#ccc' : '#16a34a'};\r\n  opacity: ${props => props.disabled ? 0.5 : 1};\r\n  transition: all 0.2s ease;\r\n  \r\n  &:hover:not(:disabled) {\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\r\n  }\r\n  \r\n  img {\r\n    width: 70%;\r\n    height: 70%;\r\n    object-fit: contain;\r\n  }\r\n`;\r\n\r\nconst UndoButton = styled(ActionButton)`\r\n  left: 20px;\r\n`;\r\n\r\nconst RedoButton = styled(ActionButton)`\r\n  right: 20px;\r\n`;\r\n\r\nconst shuffleTurnsOrder = (arr) => arr.concat(arr.splice(0, 1));\r\n\r\nconst initialColors = shuffleArray([\r\n  '#7975b9',\r\n  '#007F73',\r\n  '#FB9AD1',\r\n  '#FFC470',\r\n  '#C5FF95',\r\n  '#4793AF',\r\n  '#ff7171',\r\n]);\r\n\r\nconst Game = ({ map }) => {\r\n  const [teams, setTeams] = React.useState([]);\r\n  const [gameState, setGameState] = React.useState('prepare');\r\n  const [turnsOrder, setTurnsOrder] = React.useState([]);\r\n  const [currentTurn, setCurrentTurn] = React.useState(null);\r\n  const [roundNumber, setRoundNumber] = React.useState(0);\r\n  const [activeTeam, setActiveTeam] = React.useState(null);\r\n  const [pendingCaptureZone, setPendingCaptureZone] = React.useState(null);\r\n  const [captureState, setCaptureState] = React.useState({\r\n    attackerAnswered: false,\r\n    defenderAnswered: false,\r\n    attackerCorrect: null,\r\n    defenderCorrect: null,\r\n    firstResponder: null,\r\n    isNeutral: false,\r\n    attackerAnswer: null,\r\n    defenderAnswer: null,\r\n    responseOrder: [],\r\n    isCapital: false,\r\n    consecutiveWins: 0,\r\n    requiredWins: 3,\r\n    currentTask: null,\r\n    capitalTasks: [],\r\n  });\r\n\r\n  const [availableTasks, setAvailableTasks] = React.useState([]);\r\n\r\n  const [availableColors, setAvailableColors] = React.useState([...initialColors]);\r\n  const [usedTaskIds, setUsedTaskIds] = React.useState(new Set());\r\n\r\n  // Load available tasks on component mount\r\n  React.useEffect(() => {\r\n    const loadTasks = async () => {\r\n      try {\r\n        const tasks = [];\r\n        let taskNumber = 1;\r\n\r\n        // Loop to find all available tasks\r\n        while (taskNumber <= 100) {\r\n          try {\r\n            // 1. Fetch the text file\r\n            const response = await fetch(`/tasks/${taskNumber}.txt`);\r\n            if (!response.ok) break;\r\n\r\n            const text = await response.text();\r\n\r\n            // CRITICAL FIX: Check if server returned HTML (index.html) instead of text\r\n            if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {\r\n              break; // Stop if we hit the fallback HTML\r\n            }\r\n\r\n            // 2. Check if image exists\r\n            let hasImage = false;\r\n            try {\r\n              const imgResponse = await fetch(`/test/tasks/pics/${taskNumber}.png`, { method: 'HEAD' });\r\n              if (imgResponse.ok) {\r\n                const contentType = imgResponse.headers.get('content-type');\r\n                // Only accept if it's actually an image or if we can't check content-type but response was OK\r\n                if (!contentType || contentType.startsWith('image/')) {\r\n                  hasImage = true;\r\n                }\r\n              }\r\n            } catch (e) {\r\n              console.warn('Failed to check image', e);\r\n            }\r\n\r\n            tasks.push({\r\n              id: taskNumber,\r\n              text: text.trim(),\r\n              imagePath: hasImage ? `/test/tasks/pics/${taskNumber}.png` : null,\r\n            });\r\n\r\n            taskNumber++;\r\n          } catch (error) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        setAvailableTasks(tasks);\r\n      } catch (error) {\r\n        console.error('Error loading tasks:', error);\r\n      }\r\n    };\r\n\r\n    loadTasks();\r\n  }, []);\r\n\r\n  // Helper function to select random tasks\r\n  const selectRandomTasks = React.useCallback((count) => {\r\n    // Filter out used tasks\r\n    const unusedTasks = availableTasks.filter(task => !usedTaskIds.has(task.id));\r\n\r\n    if (unusedTasks.length === 0) return [];\r\n\r\n    const shuffled = [...unusedTasks].sort(() => Math.random() - 0.5);\r\n    return shuffled.slice(0, Math.min(count, unusedTasks.length));\r\n  }, [availableTasks, usedTaskIds]);\r\n\r\n  // History state\r\n  const [history, setHistory] = React.useState([]);\r\n  const [future, setFuture] = React.useState([]);\r\n\r\n  const recordAction = React.useCallback(() => {\r\n    const currentState = {\r\n      teams: JSON.parse(JSON.stringify(teams)),\r\n      gameState,\r\n      turnsOrder: [...turnsOrder],\r\n      currentTurn,\r\n      roundNumber,\r\n      activeTeam,\r\n      availableColors: [...availableColors],\r\n      usedTaskIds: new Set(usedTaskIds),\r\n      pendingCaptureZone,\r\n      captureState: JSON.parse(JSON.stringify(captureState)),\r\n    };\r\n    setHistory((prev) => [...prev, currentState]);\r\n    setFuture([]);\r\n  }, [teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors, usedTaskIds, pendingCaptureZone, captureState]);\r\n\r\n  const restoreState = React.useCallback((state) => {\r\n    setTeams(state.teams);\r\n    setGameState(state.gameState);\r\n    setTurnsOrder(state.turnsOrder);\r\n    setCurrentTurn(state.currentTurn);\r\n    setRoundNumber(state.roundNumber);\r\n    setActiveTeam(state.activeTeam);\r\n    setAvailableColors(state.availableColors);\r\n    setUsedTaskIds(state.usedTaskIds || new Set());\r\n\r\n    // Restore UI states\r\n    setPendingCaptureZone(state.pendingCaptureZone || null);\r\n\r\n    // If we're restoring a capture state, reset the answered states\r\n    // to prevent auto-resolution while keeping task information\r\n    if (state.captureState) {\r\n      setCaptureState({\r\n        ...state.captureState,\r\n        attackerAnswered: false,\r\n        defenderAnswered: false,\r\n        attackerCorrect: null,\r\n        defenderCorrect: null,\r\n        attackerAnswer: null,\r\n        defenderAnswer: null,\r\n        responseOrder: [],\r\n      });\r\n    } else {\r\n      setCaptureState({\r\n        attackerAnswered: false,\r\n        defenderAnswered: false,\r\n        attackerCorrect: null,\r\n        defenderCorrect: null,\r\n        firstResponder: null,\r\n        isNeutral: false,\r\n        attackerAnswer: null,\r\n        defenderAnswer: null,\r\n        responseOrder: [],\r\n        isCapital: false,\r\n        consecutiveWins: 0,\r\n        requiredWins: 3,\r\n        currentTask: null,\r\n        capitalTasks: [],\r\n      });\r\n    }\r\n  }, []);\r\n\r\n  const undo = React.useCallback(() => {\r\n    // If capture window is open\r\n    if (pendingCaptureZone !== null) {\r\n      // Special handling for capital attacks with multiple stages\r\n      if (captureState.isCapital && captureState.consecutiveWins > 0) {\r\n        // Revert to previous stage instead of closing\r\n        const previousWins = captureState.consecutiveWins - 1;\r\n        const previousTask = captureState.capitalTasks[previousWins] || captureState.capitalTasks[0];\r\n\r\n        setCaptureState({\r\n          ...captureState,\r\n          consecutiveWins: previousWins,\r\n          currentTask: previousTask,\r\n          attackerAnswered: false,\r\n          defenderAnswered: false,\r\n          attackerCorrect: null,\r\n          defenderCorrect: null,\r\n          attackerAnswer: null,\r\n          defenderAnswer: null,\r\n          responseOrder: [],\r\n        });\r\n        return;\r\n      }\r\n\r\n      // For regular attacks or first stage of capital attack, close the window\r\n      // Save the current state (with window open) to future before closing\r\n      const stateWithWindowOpen = {\r\n        teams: JSON.parse(JSON.stringify(teams)),\r\n        gameState,\r\n        turnsOrder: [...turnsOrder],\r\n        currentTurn,\r\n        roundNumber,\r\n        activeTeam,\r\n        availableColors: [...availableColors],\r\n        usedTaskIds: new Set(usedTaskIds),\r\n        pendingCaptureZone,\r\n        captureState: JSON.parse(JSON.stringify(captureState)),\r\n      };\r\n\r\n      setFuture((prev) => [stateWithWindowOpen, ...prev]);\r\n\r\n      setPendingCaptureZone(null);\r\n      setCaptureState({\r\n        attackerAnswered: false,\r\n        defenderAnswered: false,\r\n        attackerCorrect: null,\r\n        defenderCorrect: null,\r\n        firstResponder: null,\r\n        isNeutral: false,\r\n        attackerAnswer: null,\r\n        defenderAnswer: null,\r\n        responseOrder: [],\r\n        isCapital: false,\r\n        consecutiveWins: 0,\r\n        requiredWins: 3,\r\n        currentTask: null,\r\n        capitalTasks: [],\r\n      });\r\n\r\n      // Also revert the used tasks that were marked when opening this window\r\n      // by restoring from the last history state\r\n      if (history.length > 0) {\r\n        const lastState = history[history.length - 1];\r\n        if (lastState.usedTaskIds) {\r\n          setUsedTaskIds(lastState.usedTaskIds);\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (history.length === 0) return;\r\n\r\n    const previousState = history[history.length - 1];\r\n    const newHistory = history.slice(0, -1);\r\n\r\n    const currentState = {\r\n      teams: JSON.parse(JSON.stringify(teams)),\r\n      gameState,\r\n      turnsOrder: [...turnsOrder],\r\n      currentTurn,\r\n      roundNumber,\r\n      activeTeam,\r\n      availableColors: [...availableColors],\r\n      usedTaskIds: new Set(usedTaskIds),\r\n      pendingCaptureZone,\r\n      captureState: JSON.parse(JSON.stringify(captureState)),\r\n    };\r\n\r\n    setFuture((prev) => [currentState, ...prev]);\r\n    setHistory(newHistory);\r\n    restoreState(previousState);\r\n  }, [history, teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors, usedTaskIds, pendingCaptureZone, captureState, restoreState]);\r\n\r\n  const redo = React.useCallback(() => {\r\n    if (future.length === 0) return;\r\n\r\n    const nextState = future[0];\r\n    const newFuture = future.slice(1);\r\n\r\n    // Save current state to history before restoring\r\n    const currentState = {\r\n      teams: JSON.parse(JSON.stringify(teams)),\r\n      gameState,\r\n      turnsOrder: [...turnsOrder],\r\n      currentTurn,\r\n      roundNumber,\r\n      activeTeam,\r\n      availableColors: [...availableColors],\r\n      usedTaskIds: new Set(usedTaskIds),\r\n      pendingCaptureZone,\r\n      captureState: JSON.parse(JSON.stringify(captureState)),\r\n    };\r\n\r\n    setHistory((prev) => [...prev, currentState]);\r\n    setFuture(newFuture);\r\n    restoreState(nextState);\r\n  }, [future, teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors, usedTaskIds, pendingCaptureZone, captureState, restoreState]);\r\n\r\n  // Получаем basePositions из teams\r\n  const basePositions = React.useMemo(() => {\r\n    return teams.map(team => team.base).filter(Boolean);\r\n  }, [teams]);\r\n\r\n  const setBase = React.useCallback(\r\n    (zoneId, teamIndex) => {\r\n      const newTeams = [...teams];\r\n      newTeams[teamIndex].base = zoneId;\r\n      setTeams(newTeams);\r\n    },\r\n    [teams]\r\n  );\r\n\r\n  const toggleZoneToTeam = React.useCallback(\r\n    (zoneId, teamIndex) => {\r\n      const newTeams = [...teams];\r\n\r\n      // Проверяем, есть ли уже эта территория у команды\r\n      const currentTeamHasZone = newTeams[teamIndex].zones.includes(zoneId);\r\n\r\n      if (currentTeamHasZone) {\r\n        // Убираем территорию у команды\r\n        newTeams[teamIndex].zones = newTeams[teamIndex].zones.filter((z) => z !== zoneId);\r\n\r\n        // Если это была столица, убираем и столицу\r\n        if (newTeams[teamIndex].base === zoneId) {\r\n          newTeams[teamIndex].base = null;\r\n        }\r\n      } else {\r\n        // Убираем территорию у предыдущего владельца\r\n        for (let i = 0; i < newTeams.length; i++) {\r\n          if (newTeams[i].zones.includes(zoneId)) {\r\n            newTeams[i].zones = newTeams[i].zones.filter((z) => z !== zoneId);\r\n\r\n            // Если у предыдущего владельца это была столица, убираем столицу\r\n            if (newTeams[i].base === zoneId) {\r\n              newTeams[i].base = null;\r\n            }\r\n            break;\r\n          }\r\n        }\r\n\r\n        // Добавляем территорию новой команде\r\n        newTeams[teamIndex].zones.push(zoneId);\r\n\r\n        // Если это первая территория в режиме подготовки, устанавливаем столицу\r\n        if (gameState === 'prepare' && !newTeams[teamIndex].base) {\r\n          newTeams[teamIndex].base = zoneId;\r\n        }\r\n      }\r\n\r\n      setTeams(newTeams);\r\n    },\r\n    [teams, gameState]\r\n  );\r\n\r\n  const onTurnComplete = React.useCallback(() => {\r\n    const nextTeam = turnsOrder\r\n      .slice(currentTurn + 1)\r\n      .find((teamIndex) => teams[teamIndex].zones.length > 0);\r\n\r\n    if (typeof nextTeam !== 'undefined') {\r\n      setCurrentTurn(currentTurn + 1);\r\n      setActiveTeam(nextTeam);\r\n      return;\r\n    }\r\n\r\n    setRoundNumber(roundNumber + 1);\r\n    setCurrentTurn(0);\r\n\r\n    const newTurnsOrder = shuffleTurnsOrder(\r\n      [...turnsOrder]\r\n        .map((teamIndex) => (teams[teamIndex].zones.length > 0 ? teamIndex : undefined))\r\n        .filter((i) => typeof i !== 'undefined')\r\n    );\r\n\r\n    setTurnsOrder(newTurnsOrder);\r\n    setActiveTeam(newTurnsOrder[0]);\r\n  }, [currentTurn, roundNumber, teams, turnsOrder]);\r\n\r\n  const onZoneClick = React.useCallback(\r\n    (zoneId, isRightClick) => {\r\n      if (gameState === 'prepare' && activeTeam !== null) {\r\n        recordAction();\r\n        toggleZoneToTeam(zoneId, activeTeam);\r\n      }\r\n      if (gameState === 'started') {\r\n        // Ignore right-click\r\n        if (isRightClick) return;\r\n\r\n        const zoneOwner = teams.find((team) => team.zones.includes(zoneId));\r\n        const zoneOwnerId = teams.findIndex((team) => team.zones.includes(zoneId));\r\n\r\n        // neutral tile: ignore\r\n        if (!zoneOwner) {\r\n          return;\r\n        }\r\n\r\n        // own tile: ignore\r\n        if (zoneOwnerId === activeTeam) {\r\n          return;\r\n        }\r\n\r\n        // enemy tile: open confirmation window\r\n        const isCapital = zoneOwner.base === zoneId;\r\n\r\n        // Select tasks for this attack\r\n        let selectedTasks = [];\r\n        let currentTask = null;\r\n\r\n        if (isCapital) {\r\n          // For capital, select 3 different tasks\r\n          selectedTasks = selectRandomTasks(3);\r\n          currentTask = selectedTasks[0] || null;\r\n        } else {\r\n          // For regular territory, select 1 task\r\n          selectedTasks = selectRandomTasks(1);\r\n          currentTask = selectedTasks[0] || null;\r\n        }\r\n\r\n        // Mark tasks as used\r\n        if (selectedTasks.length > 0) {\r\n          setUsedTaskIds(prev => {\r\n            const next = new Set(prev);\r\n            selectedTasks.forEach(t => next.add(t.id));\r\n            return next;\r\n          });\r\n        }\r\n\r\n        // Clear future/redo stack when starting a new attack\r\n        setFuture([]);\r\n\r\n        setPendingCaptureZone(zoneId);\r\n        setCaptureState({\r\n          attackerAnswered: false,\r\n          defenderAnswered: false,\r\n          attackerCorrect: null,\r\n          defenderCorrect: null,\r\n          firstResponder: null,\r\n          isNeutral: false,\r\n          attackerAnswer: null,\r\n          defenderAnswer: null,\r\n          responseOrder: [],\r\n          isCapital: isCapital,\r\n          consecutiveWins: 0,\r\n          requiredWins: 3,\r\n          currentTask: currentTask,\r\n          capitalTasks: selectedTasks,\r\n        });\r\n      }\r\n    },\r\n    [activeTeam, gameState, onTurnComplete, teams, toggleZoneToTeam, recordAction, selectRandomTasks]\r\n  );\r\n\r\n  const cancelCapture = React.useCallback(() => {\r\n    setPendingCaptureZone(null);\r\n    setCaptureState({\r\n      attackerAnswered: false,\r\n      defenderAnswered: false,\r\n      attackerCorrect: null,\r\n      defenderCorrect: null,\r\n      firstResponder: null,\r\n      isNeutral: false,\r\n      attackerAnswer: null,\r\n      defenderAnswer: null,\r\n      responseOrder: [],\r\n    });\r\n  }, []);\r\n\r\n  const maybeResolveCapture = React.useCallback(\r\n    (state, zoneId) => {\r\n      if (!state.attackerAnswered || !state.defenderAnswered) return;\r\n\r\n      const zoneOwner = teams.find((team) => team.zones.includes(zoneId));\r\n      const zoneOwnerId = teams.findIndex((team) => team.zones.includes(zoneId));\r\n      if (!zoneOwner || zoneOwnerId === -1) {\r\n        return;\r\n      }\r\n\r\n      recordAction();\r\n\r\n      let winner = 'defender';\r\n\r\n      if (!state.attackerCorrect && !state.defenderCorrect) {\r\n        winner = 'defender';\r\n      } else if (state.attackerCorrect && !state.defenderCorrect) {\r\n        winner = 'attacker';\r\n      } else if (!state.attackerCorrect && state.defenderCorrect) {\r\n        winner = 'defender';\r\n      } else if (state.attackerCorrect && state.defenderCorrect) {\r\n        winner = state.responseOrder[0] === 'attacker' ? 'attacker' : 'defender';\r\n      }\r\n\r\n      const newTeams = [...teams];\r\n\r\n      // Handle capital attack - need 3 consecutive wins\r\n      if (state.isCapital && winner === 'attacker') {\r\n        const newConsecutiveWins = state.consecutiveWins + 1;\r\n\r\n        if (newConsecutiveWins < state.requiredWins) {\r\n          // Not enough wins yet, reset the modal for next encounter\r\n          // Use the next task for capital attacks\r\n          const nextTask = state.capitalTasks[newConsecutiveWins] || state.currentTask;\r\n\r\n          setCaptureState({\r\n            attackerAnswered: false,\r\n            defenderAnswered: false,\r\n            attackerCorrect: null,\r\n            defenderCorrect: null,\r\n            firstResponder: null,\r\n            isNeutral: false,\r\n            attackerAnswer: null,\r\n            defenderAnswer: null,\r\n            responseOrder: [],\r\n            isCapital: true,\r\n            consecutiveWins: newConsecutiveWins,\r\n            requiredWins: state.requiredWins,\r\n            currentTask: nextTask,\r\n            capitalTasks: state.capitalTasks,\r\n          });\r\n          return; // Keep modal open for next encounter\r\n        }\r\n        // If we reach here, attacker has won 3 times - continue to capture\r\n      } else if (state.isCapital && winner === 'defender') {\r\n        // Defender won, capital defense successful - close modal and end turn\r\n        // Award 100 points to defender for successful defense\r\n        newTeams[zoneOwnerId].score += 100;\r\n        setTeams(newTeams);\r\n\r\n        setPendingCaptureZone(null);\r\n        setCaptureState({\r\n          attackerAnswered: false,\r\n          defenderAnswered: false,\r\n          attackerCorrect: null,\r\n          defenderCorrect: null,\r\n          firstResponder: null,\r\n          isNeutral: false,\r\n          attackerAnswer: null,\r\n          defenderAnswer: null,\r\n          responseOrder: [],\r\n          isCapital: false,\r\n          consecutiveWins: 0,\r\n          requiredWins: 3,\r\n          currentTask: null,\r\n          capitalTasks: [],\r\n        });\r\n        onTurnComplete();\r\n        return;\r\n      }\r\n\r\n      if (winner === 'attacker' && zoneOwnerId !== activeTeam) {\r\n        if (zoneOwner.base === zoneId) {\r\n          newTeams[activeTeam].score += 400;\r\n\r\n          // Capture all zones of the defeated team\r\n          const zonesToCapture = [...newTeams[zoneOwnerId].zones];\r\n          zonesToCapture.forEach((zone) => {\r\n            if (zone !== zoneId) {\r\n              // Remove from defeated team\r\n              newTeams[zoneOwnerId].zones = newTeams[zoneOwnerId].zones.filter(z => z !== zone);\r\n              // Add to attacker team\r\n              if (!newTeams[activeTeam].zones.includes(zone)) {\r\n                newTeams[activeTeam].zones.push(zone);\r\n              }\r\n            }\r\n          });\r\n\r\n          // Remove base from defeated team\r\n          newTeams[zoneOwnerId].base = null;\r\n\r\n          // Capture the base zone\r\n          newTeams[zoneOwnerId].zones = newTeams[zoneOwnerId].zones.filter(z => z !== zoneId);\r\n          newTeams[activeTeam].zones.push(zoneId);\r\n          newTeams[activeTeam].base = zoneId;\r\n        } else {\r\n          newTeams[activeTeam].score += 100;\r\n          // Remove from defender and add to attacker\r\n          newTeams[zoneOwnerId].zones = newTeams[zoneOwnerId].zones.filter(z => z !== zoneId);\r\n          newTeams[activeTeam].zones.push(zoneId);\r\n        }\r\n      } else if (winner === 'defender') {\r\n        // Defender successfully defended - award 100 points\r\n        newTeams[zoneOwnerId].score += 100;\r\n      }\r\n\r\n      setTeams(newTeams);\r\n      setPendingCaptureZone(null);\r\n      setCaptureState({\r\n        attackerAnswered: false,\r\n        defenderAnswered: false,\r\n        attackerCorrect: null,\r\n        defenderCorrect: null,\r\n        firstResponder: null,\r\n        isNeutral: false,\r\n        attackerAnswer: null,\r\n        defenderAnswer: null,\r\n        responseOrder: [],\r\n        isCapital: false,\r\n        consecutiveWins: 0,\r\n        requiredWins: 3,\r\n        currentTask: null,\r\n        capitalTasks: [],\r\n      });\r\n      onTurnComplete();\r\n    },\r\n    [activeTeam, onTurnComplete, teams, recordAction]\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (\r\n      pendingCaptureZone &&\r\n      !captureState.isNeutral &&\r\n      captureState.attackerAnswered &&\r\n      captureState.defenderAnswered\r\n    ) {\r\n      maybeResolveCapture(captureState, pendingCaptureZone);\r\n    }\r\n  }, [captureState, pendingCaptureZone, maybeResolveCapture]);\r\n\r\n  const handleAttackerAnswer = React.useCallback(\r\n    (isCorrect) => {\r\n      if (!pendingCaptureZone) return;\r\n\r\n      // Для вражеских территорий - переключаем выбор\r\n      setCaptureState((prev) => {\r\n        // Если уже выбран этот вариант - отменяем выбор\r\n        if (prev.attackerAnswer === isCorrect) {\r\n          return {\r\n            ...prev,\r\n            attackerAnswer: null,\r\n            attackerAnswered: false,\r\n            responseOrder: prev.responseOrder.filter(item => item !== 'attacker')\r\n          };\r\n        }\r\n\r\n        const newResponseOrder = [...prev.responseOrder];\r\n        if (!newResponseOrder.includes('attacker')) {\r\n          newResponseOrder.push('attacker');\r\n        }\r\n\r\n        const next = {\r\n          ...prev,\r\n          attackerAnswer: isCorrect,\r\n          attackerAnswered: true,\r\n          attackerCorrect: isCorrect,\r\n          responseOrder: newResponseOrder,\r\n        };\r\n\r\n        return next;\r\n      });\r\n    },\r\n    [captureState.isNeutral, captureState.attackerAnswer, onTurnComplete, pendingCaptureZone, activeTeam, teams, recordAction]\r\n  );\r\n\r\n  const handleDefenderAnswer = React.useCallback(\r\n    (isCorrect) => {\r\n      if (!pendingCaptureZone) return;\r\n\r\n      setCaptureState((prev) => {\r\n        // Если уже выбран этот вариант - отменяем выбор\r\n        if (prev.defenderAnswer === isCorrect) {\r\n          return {\r\n            ...prev,\r\n            defenderAnswer: null,\r\n            defenderAnswered: false,\r\n            responseOrder: prev.responseOrder.filter(item => item !== 'defender')\r\n          };\r\n        }\r\n\r\n        const newResponseOrder = [...prev.responseOrder];\r\n        if (!newResponseOrder.includes('defender')) {\r\n          newResponseOrder.push('defender');\r\n        }\r\n\r\n        const next = {\r\n          ...prev,\r\n          defenderAnswer: isCorrect,\r\n          defenderAnswered: true,\r\n          defenderCorrect: isCorrect,\r\n          responseOrder: newResponseOrder,\r\n        };\r\n\r\n        return next;\r\n      });\r\n    },\r\n    [pendingCaptureZone]\r\n  );\r\n\r\n  // Определяем порядок для отображения - теперь функция будет возвращать порядок только для активной кнопки\r\n  const getOrderForPlayer = (player, isActive) => {\r\n    if (!isActive) return '';\r\n    const index = captureState.responseOrder.indexOf(player);\r\n    return index !== -1 ? (index + 1).toString() : '';\r\n  };\r\n\r\n  return (\r\n    <GameContainer>\r\n      <MapWrapper>\r\n        <Map\r\n          teams={teams}\r\n          basePositions={basePositions}\r\n          gameState={gameState}\r\n          disabledZones={\r\n            gameState === 'prepare' && activeTeam !== null\r\n              ? map.getAdjucentZones(\r\n                teams.filter((_, index) => index !== activeTeam).flatMap((team) => team.zones)\r\n              )\r\n              : []\r\n          }\r\n          onZoneClick={onZoneClick}\r\n        />\r\n\r\n        {/* Кнопки Undo/Redo */}\r\n        <UndoButton\r\n          disabled={history.length === 0}\r\n          onClick={undo}\r\n          title=\"Отменить последнее действие\"\r\n        >\r\n          <img src=\"/test/images/undo-icon.png\" alt=\"Отменить\" />\r\n        </UndoButton>\r\n\r\n        <RedoButton\r\n          disabled={future.length === 0}\r\n          onClick={redo}\r\n          title=\"Повторить отмененное действие\"\r\n        >\r\n          <img src=\"/test/images/redo-icon.png\" alt=\"Повторить\" />\r\n        </RedoButton>\r\n\r\n        {pendingCaptureZone && (\r\n          <CaptureModalBackdrop>\r\n            <CaptureModalCard>\r\n              {/* Left Actions (Defender) */}\r\n              <CaptureModalSideActions className=\"left\" isNeutral={false}>\r\n                <CaptureButton\r\n                  className={captureState.defenderAnswer === false ? 'active' : ''}\r\n                  onClick={() => handleDefenderAnswer(false)}\r\n                  data-order={getOrderForPlayer('defender', captureState.defenderAnswer === false)}\r\n                >\r\n                  <img src=\"/test/images/defend-wrong-icon.png\" alt=\"Защита неверно\" />\r\n                </CaptureButton>\r\n                <CaptureButton\r\n                  className={captureState.defenderAnswer === true ? 'active' : ''}\r\n                  onClick={() => handleDefenderAnswer(true)}\r\n                  data-order={getOrderForPlayer('defender', captureState.defenderAnswer === true)}\r\n                >\r\n                  <img src=\"/test/images/defend-correct-icon.png\" alt=\"Защита верно\" />\r\n                </CaptureButton>\r\n              </CaptureModalSideActions>\r\n\r\n\r\n              {/* Center Content */}\r\n              <CaptureModalContent>\r\n                <CaptureModalTitle>\r\n                  РЕГИОН {pendingCaptureZone} {captureState.isCapital && `(СТОЛИЦА ${captureState.consecutiveWins}/${captureState.requiredWins})`}\r\n                </CaptureModalTitle>\r\n                <CaptureModalText>\r\n                  {captureState.currentTask ? captureState.currentTask.text : (\r\n                    availableTasks.length > 0 && usedTaskIds.size >= availableTasks.length\r\n                      ? 'Задач нет'\r\n                      : (captureState.isCapital\r\n                        ? `Атака на столицу! Для захвата необходимо победить в ${captureState.requiredWins} схватках подряд.`\r\n                        : 'Захват вражеской территории. Здесь будет описание задания или подсказка для игрока. После выполнения задания выберите результат атаки для атакующих и защищающихся.')\r\n                  )}\r\n                </CaptureModalText>\r\n                {captureState.currentTask && captureState.currentTask.imagePath && (\r\n                  <CaptureModalImagePlaceholder>\r\n                    <img src={captureState.currentTask.imagePath} alt=\"Task illustration\" />\r\n                  </CaptureModalImagePlaceholder>\r\n                )}\r\n              </CaptureModalContent>\r\n\r\n              {/* Right Actions (Attacker) */}\r\n              <CaptureModalSideActions className=\"right\" isNeutral={false}>\r\n                <CaptureButton\r\n                  className={captureState.attackerAnswer === false ? 'active' : ''}\r\n                  onClick={() => handleAttackerAnswer(false)}\r\n                  data-order={getOrderForPlayer('attacker', captureState.attackerAnswer === false)}\r\n                >\r\n                  <img src=\"/test/images/attack-wrong-icon.png\" alt=\"Атака неверно\" />\r\n                </CaptureButton>\r\n                <CaptureButton\r\n                  className={captureState.attackerAnswer === true ? 'active' : ''}\r\n                  onClick={() => handleAttackerAnswer(true)}\r\n                  data-order={getOrderForPlayer('attacker', captureState.attackerAnswer === true)}\r\n                >\r\n                  <img src=\"/test/images/attack-correct-icon.png\" alt=\"Атака верно\" />\r\n                </CaptureButton>\r\n              </CaptureModalSideActions>\r\n            </CaptureModalCard>\r\n          </CaptureModalBackdrop>\r\n        )}\r\n      </MapWrapper>\r\n\r\n      <GameControls\r\n        teams={teams}\r\n        activeTeam={activeTeam}\r\n        pendingCaptureZone={pendingCaptureZone}\r\n        captureState={captureState}\r\n        onTeamAdded={(teamName) => {\r\n          const color = availableColors[availableColors.length - 1];\r\n          const newAvailableColors = availableColors.slice(0, -1);\r\n\r\n          recordAction();\r\n          const newTeams = [\r\n            ...teams,\r\n            {\r\n              name: teamName,\r\n              score: 1000,\r\n              zones: [],\r\n              color: color,\r\n              base: null,\r\n            },\r\n          ];\r\n          setTeams(newTeams);\r\n          setAvailableColors(newAvailableColors);\r\n        }}\r\n        onTeamClick={(teamIndex) => {\r\n          if (gameState === 'prepare') {\r\n            recordAction();\r\n            setActiveTeam(teamIndex === activeTeam ? null : teamIndex);\r\n          }\r\n        }}\r\n        onGameStart={() => {\r\n          recordAction();\r\n          setGameState('started');\r\n          setCurrentTurn(0);\r\n          setRoundNumber(1);\r\n          setTurnsOrder(teams.map((tmp, index) => index));\r\n          setActiveTeam(0);\r\n        }}\r\n        onTurnComplete={() => {\r\n          recordAction();\r\n          onTurnComplete();\r\n        }}\r\n        gameState={gameState}\r\n        currentTurn={turnsOrder[currentTurn]}\r\n        roundNumber={roundNumber}\r\n      />\r\n    </GameContainer >\r\n  );\r\n};\r\n\r\nexport default Game;\r\n"],"mappings":";;AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAOC,YAAY,MAAM,iBAAiB;AAC1C,OAAOC,GAAG,MAAM,OAAO;AACvB,SAASC,YAAY,QAAQ,gBAAgB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE9C,MAAMC,aAAa,GAAGN,MAAM,CAACO,GAAG;AAChC;AACA;AACA;AACA;AACA;AACA,CAAC;AAACC,EAAA,GANIF,aAAa;AAQnB,MAAMG,UAAU,GAAGT,MAAM,CAACO,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA,CAAC;AAACG,GAAA,GANID,UAAU;AAQhB,MAAME,oBAAoB,GAAGX,MAAM,CAACO,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACK,GAAA,GATID,oBAAoB;AAW1B,MAAME,gBAAgB,GAAGb,MAAM,CAACO,GAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACO,GAAA,GAhBID,gBAAgB;AAkBtB,MAAME,mBAAmB,GAAGf,MAAM,CAACO,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACS,GAAA,GAPID,mBAAmB;AASzB,MAAME,4BAA4B,GAAGjB,MAAM,CAACO,GAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACW,GAAA,GAtBID,4BAA4B;AAwBlC,MAAME,iBAAiB,GAAGnB,MAAM,CAACoB,EAAE;AACnC;AACA;AACA;AACA;AACA,CAAC;AAACC,GAAA,GALIF,iBAAiB;AAOvB,MAAMG,gBAAgB,GAAGtB,MAAM,CAACuB,CAAC;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC;AAACC,GAAA,GANIF,gBAAgB;AAQtB,MAAMG,uBAAuB,GAAGzB,MAAM,CAACO,GAAG;AAC1C;AACA;AACA;AACA,qBAAqBmB,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}