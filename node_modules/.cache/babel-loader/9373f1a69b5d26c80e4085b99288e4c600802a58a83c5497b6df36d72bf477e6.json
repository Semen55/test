{"ast":null,"code":"var _jsxFileName = \"D:\\\\siteauth\\\\my-website \\u2014 \\u043A\\u043E\\u043F\\u0438\\u044F\\\\src\\\\components\\\\game.js\",\n  _s = $RefreshSig$();\nimport * as React from 'react';\nimport styled from 'styled-components';\nimport GameControls from './game-controls';\nimport Map from './map';\nimport { shuffleArray } from '../logic/utils';\n\n// ... (все стили остаются без изменений)\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Game = ({\n  map\n}) => {\n  _s();\n  const [teams, setTeams] = React.useState([]);\n  const [gameState, setGameState] = React.useState('prepare');\n  const [turnsOrder, setTurnsOrder] = React.useState([]);\n  const [currentTurn, setCurrentTurn] = React.useState(null);\n  const [roundNumber, setRoundNumber] = React.useState(0);\n  const [activeTeam, setActiveTeam] = React.useState(null);\n  const [pendingCaptureZone, setPendingCaptureZone] = React.useState(null);\n  const [captureState, setCaptureState] = React.useState({\n    attackerAnswered: false,\n    defenderAnswered: false,\n    attackerCorrect: null,\n    defenderCorrect: null,\n    firstResponder: null,\n    isNeutral: false,\n    attackerAnswer: null,\n    defenderAnswer: null,\n    responseOrder: []\n  });\n  const [availableColors, setAvailableColors] = React.useState([...initialColors]);\n\n  // Новые состояния для undo/redo\n  const [history, setHistory] = React.useState([]);\n  const [future, setFuture] = React.useState([]);\n\n  // Функция для сохранения текущего состояния в историю\n  const saveStateToHistory = React.useCallback(() => {\n    const currentState = {\n      teams: JSON.parse(JSON.stringify(teams)),\n      gameState,\n      turnsOrder: [...turnsOrder],\n      currentTurn,\n      roundNumber,\n      activeTeam,\n      availableColors: [...availableColors]\n    };\n    setHistory(prev => [...prev, currentState]);\n    setFuture([]); // Очищаем будущие состояния при новом действии\n  }, [teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors]);\n\n  // Функция отката действия\n  const undo = React.useCallback(() => {\n    if (history.length === 0) return;\n    const currentState = {\n      teams: JSON.parse(JSON.stringify(teams)),\n      gameState,\n      turnsOrder: [...turnsOrder],\n      currentTurn,\n      roundNumber,\n      activeTeam,\n      availableColors: [...availableColors]\n    };\n    const previousState = history[history.length - 1];\n    setFuture(prev => [currentState, ...prev]);\n    setHistory(prev => prev.slice(0, -1));\n\n    // Восстанавливаем предыдущее состояние\n    setTeams(previousState.teams);\n    setGameState(previousState.gameState);\n    setTurnsOrder(previousState.turnsOrder);\n    setCurrentTurn(previousState.currentTurn);\n    setRoundNumber(previousState.roundNumber);\n    setActiveTeam(previousState.activeTeam);\n    setAvailableColors(previousState.availableColors);\n\n    // Сбрасываем временные состояния\n    setPendingCaptureZone(null);\n    setCaptureState({\n      attackerAnswered: false,\n      defenderAnswered: false,\n      attackerCorrect: null,\n      defenderCorrect: null,\n      firstResponder: null,\n      isNeutral: false,\n      attackerAnswer: null,\n      defenderAnswer: null,\n      responseOrder: []\n    });\n  }, [history, teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors]);\n\n  // Функция повтора действия\n  const redo = React.useCallback(() => {\n    if (future.length === 0) return;\n    const nextState = future[0];\n    setFuture(prev => prev.slice(1));\n    setHistory(prev => [...prev, {\n      teams: JSON.parse(JSON.stringify(teams)),\n      gameState,\n      turnsOrder: [...turnsOrder],\n      currentTurn,\n      roundNumber,\n      activeTeam,\n      availableColors: [...availableColors]\n    }]);\n\n    // Восстанавливаем следующее состояние\n    setTeams(nextState.teams);\n    setGameState(nextState.gameState);\n    setTurnsOrder(nextState.turnsOrder);\n    setCurrentTurn(nextState.currentTurn);\n    setRoundNumber(nextState.roundNumber);\n    setActiveTeam(nextState.activeTeam);\n    setAvailableColors(nextState.availableColors);\n\n    // Сбрасываем временные состояния\n    setPendingCaptureZone(null);\n    setCaptureState({\n      attackerAnswered: false,\n      defenderAnswered: false,\n      attackerCorrect: null,\n      defenderCorrect: null,\n      firstResponder: null,\n      isNeutral: false,\n      attackerAnswer: null,\n      defenderAnswer: null,\n      responseOrder: []\n    });\n  }, [future, teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors]);\n\n  // Получаем basePositions из teams\n  const basePositions = React.useMemo(() => {\n    return teams.map(team => team.base).filter(Boolean);\n  }, [teams]);\n  const setBase = React.useCallback((zoneId, teamIndex) => {\n    saveStateToHistory(); // Сохраняем состояние перед изменением\n    const newTeams = [...teams];\n    newTeams[teamIndex].base = zoneId;\n    setTeams(newTeams);\n  }, [teams, saveStateToHistory]);\n  const toggleZoneToTeam = React.useCallback((zoneId, teamIndex) => {\n    saveStateToHistory(); // Сохраняем состояние перед изменением\n    const newTeams = [...teams];\n\n    // Проверяем, есть ли уже эта территория у команды\n    const currentTeamHasZone = newTeams[teamIndex].zones.includes(zoneId);\n    if (currentTeamHasZone) {\n      // Убираем территорию у команды\n      newTeams[teamIndex].zones = newTeams[teamIndex].zones.filter(z => z !== zoneId);\n\n      // Если это была столица, убираем и столицу\n      if (newTeams[teamIndex].base === zoneId) {\n        newTeams[teamIndex].base = null;\n      }\n    } else {\n      // Убираем территорию у предыдущего владельца\n      for (let i = 0; i < newTeams.length; i++) {\n        if (newTeams[i].zones.includes(zoneId)) {\n          newTeams[i].zones = newTeams[i].zones.filter(z => z !== zoneId);\n\n          // Если у предыдущего владельца это была столица, убираем столицу\n          if (newTeams[i].base === zoneId) {\n            newTeams[i].base = null;\n          }\n          break;\n        }\n      }\n\n      // Добавляем территорию новой команде\n      newTeams[teamIndex].zones.push(zoneId);\n\n      // Если это первая территория в режиме подготовки, устанавливаем столицу\n      if (gameState === 'prepare' && !newTeams[teamIndex].base) {\n        newTeams[teamIndex].base = zoneId;\n      }\n    }\n    setTeams(newTeams);\n  }, [teams, gameState, saveStateToHistory]);\n  const onTurnComplete = React.useCallback(() => {\n    saveStateToHistory(); // Сохраняем состояние перед изменением\n    const nextTeam = turnsOrder.slice(currentTurn + 1).find(teamIndex => teams[teamIndex].zones.length > 0);\n    if (typeof nextTeam !== 'undefined') {\n      setCurrentTurn(currentTurn + 1);\n      setActiveTeam(nextTeam);\n      return;\n    }\n    setRoundNumber(roundNumber + 1);\n    setCurrentTurn(0);\n    const newTurnsOrder = shuffleTurnsOrder([...turnsOrder].map(teamIndex => teams[teamIndex].zones.length > 0 ? teamIndex : undefined).filter(i => typeof i !== 'undefined'));\n    setTurnsOrder(newTurnsOrder);\n    setActiveTeam(newTurnsOrder[0]);\n  }, [currentTurn, roundNumber, teams, turnsOrder, saveStateToHistory]);\n  const onZoneClick = React.useCallback((zoneId, isRightClick) => {\n    if (gameState === 'prepare' && activeTeam !== null) {\n      toggleZoneToTeam(zoneId, activeTeam);\n    }\n    if (gameState === 'started') {\n      const zoneOwner = teams.find(team => team.zones.includes(zoneId));\n      const zoneOwnerId = teams.findIndex(team => team.zones.includes(zoneId));\n      const newTeams = [...teams];\n      if (isRightClick) {\n        if (!zoneOwner || zoneOwnerId === activeTeam) return;\n        saveStateToHistory(); // Сохраняем состояние перед изменением\n        if (zoneOwner && zoneOwner.base === zoneId) {\n          newTeams[zoneOwnerId].score += 200;\n        } else {\n          newTeams[zoneOwnerId].score += 100;\n        }\n        setTeams(newTeams);\n        onTurnComplete();\n      }\n      if (!isRightClick) {\n        // neutral tile: open capture modal\n        if (!zoneOwner) {\n          setPendingCaptureZone(zoneId);\n          setCaptureState({\n            attackerAnswered: false,\n            defenderAnswered: false,\n            attackerCorrect: null,\n            defenderCorrect: null,\n            firstResponder: null,\n            isNeutral: true,\n            attackerAnswer: null,\n            defenderAnswer: null,\n            responseOrder: []\n          });\n          return;\n        }\n\n        // own tile: ignore\n        if (zoneOwnerId === activeTeam) {\n          return;\n        }\n\n        // enemy tile: open confirmation window\n        setPendingCaptureZone(zoneId);\n        setCaptureState({\n          attackerAnswered: false,\n          defenderAnswered: false,\n          attackerCorrect: null,\n          defenderCorrect: null,\n          firstResponder: null,\n          isNeutral: false,\n          attackerAnswer: null,\n          defenderAnswer: null,\n          responseOrder: []\n        });\n      }\n    }\n  }, [activeTeam, gameState, onTurnComplete, teams, toggleZoneToTeam, saveStateToHistory]);\n\n  // ... (остальные функции остаются без изменений, но добавляем saveStateToHistory где нужно)\n\n  const handleAttackerAnswer = React.useCallback(isCorrect => {\n    if (!pendingCaptureZone) return;\n\n    // Для нейтральных территорий\n    if (captureState.isNeutral) {\n      saveStateToHistory(); // Сохраняем состояние перед изменением\n      // ... остальной код без изменений\n    }\n\n    // Для вражеских территорий - переключаем выбор\n    setCaptureState(prev => {\n      // Если уже выбран этот вариант - отменяем выбор\n      if (prev.attackerAnswer === isCorrect) {\n        return {\n          ...prev,\n          attackerAnswer: null,\n          attackerAnswered: false,\n          responseOrder: prev.responseOrder.filter(item => item !== 'attacker')\n        };\n      }\n      const newResponseOrder = [...prev.responseOrder];\n      if (!newResponseOrder.includes('attacker')) {\n        newResponseOrder.push('attacker');\n      }\n      const next = {\n        ...prev,\n        attackerAnswer: isCorrect,\n        attackerAnswered: true,\n        attackerCorrect: isCorrect,\n        responseOrder: newResponseOrder\n      };\n\n      // Проверяем, оба ли ответили\n      if (next.attackerAnswered && next.defenderAnswered) {\n        saveStateToHistory(); // Сохраняем состояние перед разрешением захвата\n        maybeResolveCapture(next, pendingCaptureZone);\n      }\n      return next;\n    });\n  }, [captureState.isNeutral, captureState.attackerAnswer, maybeResolveCapture, onTurnComplete, pendingCaptureZone, activeTeam, teams, saveStateToHistory]);\n\n  // Аналогично добавляем saveStateToHistory в handleDefenderAnswer\n\n  // ... (остальной код компонента без изменений)\n\n  return /*#__PURE__*/_jsxDEV(GameContainer, {\n    children: [/*#__PURE__*/_jsxDEV(Map, {\n      teams: teams,\n      basePositions: basePositions,\n      gameState: gameState,\n      disabledZones: gameState === 'prepare' && activeTeam !== null ? map.getAdjucentZones(teams.filter((_, index) => index !== activeTeam).flatMap(team => team.zones)) : [],\n      onZoneClick: onZoneClick\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 337,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(GameControls, {\n      teams: teams,\n      activeTeam: activeTeam,\n      onTeamAdded: teamName => {\n        saveStateToHistory(); // Сохраняем состояние перед добавлением команды\n        const color = availableColors[availableColors.length - 1];\n        const newAvailableColors = availableColors.slice(0, -1);\n        const newTeams = [...teams, {\n          name: teamName,\n          score: 1000,\n          zones: [],\n          color: color,\n          base: null\n        }];\n        setTeams(newTeams);\n        setAvailableColors(newAvailableColors);\n      },\n      onTeamClick: teamIndex => {\n        if (gameState === 'prepare') {\n          setActiveTeam(teamIndex === activeTeam ? null : teamIndex);\n        }\n      },\n      onGameStart: () => {\n        saveStateToHistory(); // Сохраняем состояние перед началом игры\n        setGameState('started');\n        setCurrentTurn(0);\n        setRoundNumber(1);\n        setTurnsOrder(teams.map((tmp, index) => index));\n        setActiveTeam(0);\n      },\n      onTurnComplete: onTurnComplete,\n      gameState: gameState,\n      currentTurn: turnsOrder[currentTurn],\n      roundNumber: roundNumber\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 350,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(UndoButton, {\n      disabled: history.length === 0,\n      onClick: undo,\n      title: history.length === 0 ? \"Нет действий для отмены\" : \"Отменить последнее действие\",\n      children: /*#__PURE__*/_jsxDEV(\"img\", {\n        src: \"/images/undo-icon.png\",\n        alt: \"\\u041E\\u0442\\u043C\\u0435\\u043D\\u0438\\u0442\\u044C\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 396,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 391,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(RedoButton, {\n      disabled: future.length === 0,\n      onClick: redo,\n      title: future.length === 0 ? \"Нет действий для повтора\" : \"Повторить отмененное действие\",\n      children: /*#__PURE__*/_jsxDEV(\"img\", {\n        src: \"/images/redo-icon.png\",\n        alt: \"\\u041F\\u043E\\u0432\\u0442\\u043E\\u0440\\u0438\\u0442\\u044C\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 404,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 399,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 336,\n    columnNumber: 5\n  }, this);\n};\n_s(Game, \"s4hQ4mdlLzmsl4Arv5I3SO3bz98=\");\n_c = Game;\nexport default Game;\nvar _c;\n$RefreshReg$(_c, \"Game\");","map":{"version":3,"names":["React","styled","GameControls","Map","shuffleArray","jsxDEV","_jsxDEV","Game","map","_s","teams","setTeams","useState","gameState","setGameState","turnsOrder","setTurnsOrder","currentTurn","setCurrentTurn","roundNumber","setRoundNumber","activeTeam","setActiveTeam","pendingCaptureZone","setPendingCaptureZone","captureState","setCaptureState","attackerAnswered","defenderAnswered","attackerCorrect","defenderCorrect","firstResponder","isNeutral","attackerAnswer","defenderAnswer","responseOrder","availableColors","setAvailableColors","initialColors","history","setHistory","future","setFuture","saveStateToHistory","useCallback","currentState","JSON","parse","stringify","prev","undo","length","previousState","slice","redo","nextState","basePositions","useMemo","team","base","filter","Boolean","setBase","zoneId","teamIndex","newTeams","toggleZoneToTeam","currentTeamHasZone","zones","includes","z","i","push","onTurnComplete","nextTeam","find","newTurnsOrder","shuffleTurnsOrder","undefined","onZoneClick","isRightClick","zoneOwner","zoneOwnerId","findIndex","score","handleAttackerAnswer","isCorrect","item","newResponseOrder","next","maybeResolveCapture","GameContainer","children","disabledZones","getAdjucentZones","_","index","flatMap","fileName","_jsxFileName","lineNumber","columnNumber","onTeamAdded","teamName","color","newAvailableColors","name","onTeamClick","onGameStart","tmp","UndoButton","disabled","onClick","title","src","alt","RedoButton","_c","$RefreshReg$"],"sources":["D:/siteauth/my-website — копия/src/components/game.js"],"sourcesContent":["import * as React from 'react';\r\nimport styled from 'styled-components';\r\nimport GameControls from './game-controls';\r\nimport Map from './map';\r\nimport { shuffleArray } from '../logic/utils';\r\n\r\n// ... (все стили остаются без изменений)\r\n\r\nconst Game = ({ map }) => {\r\n  const [teams, setTeams] = React.useState([]);\r\n  const [gameState, setGameState] = React.useState('prepare');\r\n  const [turnsOrder, setTurnsOrder] = React.useState([]);\r\n  const [currentTurn, setCurrentTurn] = React.useState(null);\r\n  const [roundNumber, setRoundNumber] = React.useState(0);\r\n  const [activeTeam, setActiveTeam] = React.useState(null);\r\n  const [pendingCaptureZone, setPendingCaptureZone] = React.useState(null);\r\n  const [captureState, setCaptureState] = React.useState({\r\n    attackerAnswered: false,\r\n    defenderAnswered: false,\r\n    attackerCorrect: null,\r\n    defenderCorrect: null,\r\n    firstResponder: null,\r\n    isNeutral: false,\r\n    attackerAnswer: null,\r\n    defenderAnswer: null,\r\n    responseOrder: [],\r\n  });\r\n  \r\n  const [availableColors, setAvailableColors] = React.useState([...initialColors]);\r\n\r\n  // Новые состояния для undo/redo\r\n  const [history, setHistory] = React.useState([]);\r\n  const [future, setFuture] = React.useState([]);\r\n\r\n  // Функция для сохранения текущего состояния в историю\r\n  const saveStateToHistory = React.useCallback(() => {\r\n    const currentState = {\r\n      teams: JSON.parse(JSON.stringify(teams)),\r\n      gameState,\r\n      turnsOrder: [...turnsOrder],\r\n      currentTurn,\r\n      roundNumber,\r\n      activeTeam,\r\n      availableColors: [...availableColors]\r\n    };\r\n    \r\n    setHistory(prev => [...prev, currentState]);\r\n    setFuture([]); // Очищаем будущие состояния при новом действии\r\n  }, [teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors]);\r\n\r\n  // Функция отката действия\r\n  const undo = React.useCallback(() => {\r\n    if (history.length === 0) return;\r\n    \r\n    const currentState = {\r\n      teams: JSON.parse(JSON.stringify(teams)),\r\n      gameState,\r\n      turnsOrder: [...turnsOrder],\r\n      currentTurn,\r\n      roundNumber,\r\n      activeTeam,\r\n      availableColors: [...availableColors]\r\n    };\r\n    \r\n    const previousState = history[history.length - 1];\r\n    \r\n    setFuture(prev => [currentState, ...prev]);\r\n    setHistory(prev => prev.slice(0, -1));\r\n    \r\n    // Восстанавливаем предыдущее состояние\r\n    setTeams(previousState.teams);\r\n    setGameState(previousState.gameState);\r\n    setTurnsOrder(previousState.turnsOrder);\r\n    setCurrentTurn(previousState.currentTurn);\r\n    setRoundNumber(previousState.roundNumber);\r\n    setActiveTeam(previousState.activeTeam);\r\n    setAvailableColors(previousState.availableColors);\r\n    \r\n    // Сбрасываем временные состояния\r\n    setPendingCaptureZone(null);\r\n    setCaptureState({\r\n      attackerAnswered: false,\r\n      defenderAnswered: false,\r\n      attackerCorrect: null,\r\n      defenderCorrect: null,\r\n      firstResponder: null,\r\n      isNeutral: false,\r\n      attackerAnswer: null,\r\n      defenderAnswer: null,\r\n      responseOrder: [],\r\n    });\r\n  }, [history, teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors]);\r\n\r\n  // Функция повтора действия\r\n  const redo = React.useCallback(() => {\r\n    if (future.length === 0) return;\r\n    \r\n    const nextState = future[0];\r\n    \r\n    setFuture(prev => prev.slice(1));\r\n    setHistory(prev => [...prev, {\r\n      teams: JSON.parse(JSON.stringify(teams)),\r\n      gameState,\r\n      turnsOrder: [...turnsOrder],\r\n      currentTurn,\r\n      roundNumber,\r\n      activeTeam,\r\n      availableColors: [...availableColors]\r\n    }]);\r\n    \r\n    // Восстанавливаем следующее состояние\r\n    setTeams(nextState.teams);\r\n    setGameState(nextState.gameState);\r\n    setTurnsOrder(nextState.turnsOrder);\r\n    setCurrentTurn(nextState.currentTurn);\r\n    setRoundNumber(nextState.roundNumber);\r\n    setActiveTeam(nextState.activeTeam);\r\n    setAvailableColors(nextState.availableColors);\r\n    \r\n    // Сбрасываем временные состояния\r\n    setPendingCaptureZone(null);\r\n    setCaptureState({\r\n      attackerAnswered: false,\r\n      defenderAnswered: false,\r\n      attackerCorrect: null,\r\n      defenderCorrect: null,\r\n      firstResponder: null,\r\n      isNeutral: false,\r\n      attackerAnswer: null,\r\n      defenderAnswer: null,\r\n      responseOrder: [],\r\n    });\r\n  }, [future, teams, gameState, turnsOrder, currentTurn, roundNumber, activeTeam, availableColors]);\r\n\r\n  // Получаем basePositions из teams\r\n  const basePositions = React.useMemo(() => {\r\n    return teams.map(team => team.base).filter(Boolean);\r\n  }, [teams]);\r\n\r\n  const setBase = React.useCallback(\r\n    (zoneId, teamIndex) => {\r\n      saveStateToHistory(); // Сохраняем состояние перед изменением\r\n      const newTeams = [...teams];\r\n      newTeams[teamIndex].base = zoneId;\r\n      setTeams(newTeams);\r\n    },\r\n    [teams, saveStateToHistory]\r\n  );\r\n\r\n  const toggleZoneToTeam = React.useCallback(\r\n    (zoneId, teamIndex) => {\r\n      saveStateToHistory(); // Сохраняем состояние перед изменением\r\n      const newTeams = [...teams];\r\n\r\n      // Проверяем, есть ли уже эта территория у команды\r\n      const currentTeamHasZone = newTeams[teamIndex].zones.includes(zoneId);\r\n      \r\n      if (currentTeamHasZone) {\r\n        // Убираем территорию у команды\r\n        newTeams[teamIndex].zones = newTeams[teamIndex].zones.filter((z) => z !== zoneId);\r\n        \r\n        // Если это была столица, убираем и столицу\r\n        if (newTeams[teamIndex].base === zoneId) {\r\n          newTeams[teamIndex].base = null;\r\n        }\r\n      } else {\r\n        // Убираем территорию у предыдущего владельца\r\n        for (let i = 0; i < newTeams.length; i++) {\r\n          if (newTeams[i].zones.includes(zoneId)) {\r\n            newTeams[i].zones = newTeams[i].zones.filter((z) => z !== zoneId);\r\n            \r\n            // Если у предыдущего владельца это была столица, убираем столицу\r\n            if (newTeams[i].base === zoneId) {\r\n              newTeams[i].base = null;\r\n            }\r\n            break;\r\n          }\r\n        }\r\n        \r\n        // Добавляем территорию новой команде\r\n        newTeams[teamIndex].zones.push(zoneId);\r\n        \r\n        // Если это первая территория в режиме подготовки, устанавливаем столицу\r\n        if (gameState === 'prepare' && !newTeams[teamIndex].base) {\r\n          newTeams[teamIndex].base = zoneId;\r\n        }\r\n      }\r\n\r\n      setTeams(newTeams);\r\n    },\r\n    [teams, gameState, saveStateToHistory]\r\n  );\r\n\r\n  const onTurnComplete = React.useCallback(() => {\r\n    saveStateToHistory(); // Сохраняем состояние перед изменением\r\n    const nextTeam = turnsOrder\r\n      .slice(currentTurn + 1)\r\n      .find((teamIndex) => teams[teamIndex].zones.length > 0);\r\n\r\n    if (typeof nextTeam !== 'undefined') {\r\n      setCurrentTurn(currentTurn + 1);\r\n      setActiveTeam(nextTeam);\r\n      return;\r\n    }\r\n\r\n    setRoundNumber(roundNumber + 1);\r\n    setCurrentTurn(0);\r\n\r\n    const newTurnsOrder = shuffleTurnsOrder(\r\n      [...turnsOrder]\r\n        .map((teamIndex) => (teams[teamIndex].zones.length > 0 ? teamIndex : undefined))\r\n        .filter((i) => typeof i !== 'undefined')\r\n    );\r\n\r\n    setTurnsOrder(newTurnsOrder);\r\n    setActiveTeam(newTurnsOrder[0]);\r\n  }, [currentTurn, roundNumber, teams, turnsOrder, saveStateToHistory]);\r\n\r\n  const onZoneClick = React.useCallback(\r\n    (zoneId, isRightClick) => {\r\n      if (gameState === 'prepare' && activeTeam !== null) {\r\n        toggleZoneToTeam(zoneId, activeTeam);\r\n      }\r\n      if (gameState === 'started') {\r\n        const zoneOwner = teams.find((team) => team.zones.includes(zoneId));\r\n        const zoneOwnerId = teams.findIndex((team) => team.zones.includes(zoneId));\r\n        const newTeams = [...teams];\r\n\r\n        if (isRightClick) {\r\n          if (!zoneOwner || zoneOwnerId === activeTeam) return;\r\n\r\n          saveStateToHistory(); // Сохраняем состояние перед изменением\r\n          if (zoneOwner && zoneOwner.base === zoneId) {\r\n            newTeams[zoneOwnerId].score += 200;\r\n          } else {\r\n            newTeams[zoneOwnerId].score += 100;\r\n          }\r\n          setTeams(newTeams);\r\n          onTurnComplete();\r\n        }\r\n        if (!isRightClick) {\r\n          // neutral tile: open capture modal\r\n          if (!zoneOwner) {\r\n            setPendingCaptureZone(zoneId);\r\n            setCaptureState({\r\n              attackerAnswered: false,\r\n              defenderAnswered: false,\r\n              attackerCorrect: null,\r\n              defenderCorrect: null,\r\n              firstResponder: null,\r\n              isNeutral: true,\r\n              attackerAnswer: null,\r\n              defenderAnswer: null,\r\n              responseOrder: [],\r\n            });\r\n            return;\r\n          }\r\n\r\n          // own tile: ignore\r\n          if (zoneOwnerId === activeTeam) {\r\n            return;\r\n          }\r\n\r\n          // enemy tile: open confirmation window\r\n          setPendingCaptureZone(zoneId);\r\n          setCaptureState({\r\n            attackerAnswered: false,\r\n            defenderAnswered: false,\r\n            attackerCorrect: null,\r\n            defenderCorrect: null,\r\n            firstResponder: null,\r\n            isNeutral: false,\r\n            attackerAnswer: null,\r\n            defenderAnswer: null,\r\n            responseOrder: [],\r\n          });\r\n        }\r\n      }\r\n    },\r\n    [activeTeam, gameState, onTurnComplete, teams, toggleZoneToTeam, saveStateToHistory]\r\n  );\r\n\r\n  // ... (остальные функции остаются без изменений, но добавляем saveStateToHistory где нужно)\r\n\r\n  const handleAttackerAnswer = React.useCallback(\r\n    (isCorrect) => {\r\n      if (!pendingCaptureZone) return;\r\n      \r\n      // Для нейтральных территорий\r\n      if (captureState.isNeutral) {\r\n        saveStateToHistory(); // Сохраняем состояние перед изменением\r\n        // ... остальной код без изменений\r\n      }\r\n\r\n      // Для вражеских территорий - переключаем выбор\r\n      setCaptureState((prev) => {\r\n        // Если уже выбран этот вариант - отменяем выбор\r\n        if (prev.attackerAnswer === isCorrect) {\r\n          return {\r\n            ...prev,\r\n            attackerAnswer: null,\r\n            attackerAnswered: false,\r\n            responseOrder: prev.responseOrder.filter(item => item !== 'attacker')\r\n          };\r\n        }\r\n\r\n        const newResponseOrder = [...prev.responseOrder];\r\n        if (!newResponseOrder.includes('attacker')) {\r\n          newResponseOrder.push('attacker');\r\n        }\r\n\r\n        const next = {\r\n          ...prev,\r\n          attackerAnswer: isCorrect,\r\n          attackerAnswered: true,\r\n          attackerCorrect: isCorrect,\r\n          responseOrder: newResponseOrder,\r\n        };\r\n        \r\n        // Проверяем, оба ли ответили\r\n        if (next.attackerAnswered && next.defenderAnswered) {\r\n          saveStateToHistory(); // Сохраняем состояние перед разрешением захвата\r\n          maybeResolveCapture(next, pendingCaptureZone);\r\n        }\r\n        return next;\r\n      });\r\n    },\r\n    [captureState.isNeutral, captureState.attackerAnswer, maybeResolveCapture, onTurnComplete, pendingCaptureZone, activeTeam, teams, saveStateToHistory]\r\n  );\r\n\r\n  // Аналогично добавляем saveStateToHistory в handleDefenderAnswer\r\n\r\n  // ... (остальной код компонента без изменений)\r\n\r\n  return (\r\n    <GameContainer>\r\n      <Map\r\n        teams={teams}\r\n        basePositions={basePositions}\r\n        gameState={gameState}\r\n        disabledZones={\r\n          gameState === 'prepare' && activeTeam !== null\r\n            ? map.getAdjucentZones(\r\n                teams.filter((_, index) => index !== activeTeam).flatMap((team) => team.zones)\r\n              )\r\n            : []\r\n        }\r\n        onZoneClick={onZoneClick}\r\n      />\r\n      <GameControls\r\n        teams={teams}\r\n        activeTeam={activeTeam}\r\n        onTeamAdded={(teamName) => {\r\n          saveStateToHistory(); // Сохраняем состояние перед добавлением команды\r\n          const color = availableColors[availableColors.length - 1];\r\n          const newAvailableColors = availableColors.slice(0, -1);\r\n          \r\n          const newTeams = [\r\n            ...teams,\r\n            {\r\n              name: teamName,\r\n              score: 1000,\r\n              zones: [],\r\n              color: color,\r\n              base: null,\r\n            },\r\n          ];\r\n          setTeams(newTeams);\r\n          setAvailableColors(newAvailableColors);\r\n        }}\r\n        onTeamClick={(teamIndex) => {\r\n          if (gameState === 'prepare') {\r\n            setActiveTeam(teamIndex === activeTeam ? null : teamIndex);\r\n          }\r\n        }}\r\n        onGameStart={() => {\r\n          saveStateToHistory(); // Сохраняем состояние перед началом игры\r\n          setGameState('started');\r\n          setCurrentTurn(0);\r\n          setRoundNumber(1);\r\n          setTurnsOrder(teams.map((tmp, index) => index));\r\n          setActiveTeam(0);\r\n        }}\r\n        onTurnComplete={onTurnComplete}\r\n        gameState={gameState}\r\n        currentTurn={turnsOrder[currentTurn]}\r\n        roundNumber={roundNumber}\r\n      />\r\n      \r\n      {/* Обновленные кнопки Undo/Redo */}\r\n      <UndoButton \r\n        disabled={history.length === 0}\r\n        onClick={undo}\r\n        title={history.length === 0 ? \"Нет действий для отмены\" : \"Отменить последнее действие\"}\r\n      >\r\n        <img src=\"/images/undo-icon.png\" alt=\"Отменить\" />\r\n      </UndoButton>\r\n      \r\n      <RedoButton \r\n        disabled={future.length === 0}\r\n        onClick={redo}\r\n        title={future.length === 0 ? \"Нет действий для повтора\" : \"Повторить отмененное действие\"}\r\n      >\r\n        <img src=\"/images/redo-icon.png\" alt=\"Повторить\" />\r\n      </RedoButton>\r\n      \r\n      {/* ... (остальной код модального окна без изменений) */}\r\n    </GameContainer>\r\n  );\r\n};\r\n\r\nexport default Game;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}